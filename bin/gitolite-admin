#!/usr/bin/perl -w

use Cwd 'realpath';
use Getopt::Long;
use File::Glob 'bsd_glob';
use File::Temp (qw( tempfile tempdir ));
use File::Basename (qw( dirname basename ));
use FindBin;
use strict;
use warnings;

# global regex definitions
###########################

my ($perms_rx, $repo_rx, $user_rx, $fp_rx) = (
  '-|C|R|RW\+?(?:C?D?|D?C?)M?',
  '[\w\d.-]+',
  '[\w\d.-]+',
  '[\da-z]+',
);

# configuration parameters
###########################

my ($gl_repo_dir, $gl_user, $gl_host, $gl_config, $gl_keydir);
my ($debug, $info, $pretend);

# $gl_repo_dir = untaint_path($ENV{GL_REPO_DIR} || "$ENV{HOME}/gitolite-admin");
$gl_user = untaint_environment('GL_USER') || 'git';
$gl_host = untaint_environment('GL_HOST') || 'localhost';

# untaint PATH
$ENV{PATH} = '/bin:/usr/bin';

# helper functions
###################
sub untaint_var
{
  my ($var, $name, $rx) = @_;

  return unless $var;
  $name = 'variable' unless $name;
  $rx = qr/^([\w\d.-]+)$/ unless $rx;

  unless ($var =~ $rx) {
    die "bad $name: '$var'.\n";
  }

  return $1;
}

sub untaint_path
{
  my ($var, $base) = @_;

  return unless $var;
  $base = (getpwuid $<)[7] unless $base;

  if ($var =~ /^(-)$/) {
    return $1;
  }

  my ($path) = realpath($var);
  unless ($path) {
    die "bad path '$var': $!.\n";
  }
  if ($path =~ /^($base.*)$/) {
    return $1;
  }

  die "bad path '$var'.\n";
}

sub untaint_environment
{
  my ($var) = @_;
  my ($untaint);

  return '' unless ($ENV{$var});
  
  eval { $untaint = untaint_var($ENV{$var}, @_) };
  if ($@) {
    die "bad environment variable '$var'.\n";
  }

  return $untaint;
}

sub info
{
  printf @_ if $info;
}

sub debug
{
  printf STDERR @_ if $debug;
}

sub trim
{
  return unless @_;

  my (@list) = @_;
  for my $s (@list) {
    $s =~ s/^\s+|\s+$//g;
  }
  return wantarray? @list : $list[0];
}

sub run
{
  my ($out);

  debug "[exec] %s\n", join(' ', @_);

  $out = `@_`;

  if ($?) {
    if ($out ne '') {
      $out =~ s/^/  /gm;
      $out = sprintf "command output:\n%s\n", $out;
    }
    die sprintf("error running '%s', exit code: %d.\n%s",
      join(' ', @_) . "\n", $? >> 8, $out);
  }

  return $out;
}

sub parse_rules
{
  my (%config, $errors, $cur_repo);

  open CONF, "<$gl_config" or die "can't open rules file: $!\n.";
  while (<CONF>)
  {
    s/^ *//;
    chop;
    if (/^#/ or /^$/) {
      # skip comments and empty lines
    } elsif (/^repo (.*)/) {
      my ($repo) = $1;
      if ($repo =~ / /) {
        $errors .= "[line $.] repo lists are not supported.\n";
      } else {
        $config{$repo}{perms} = [] unless $config{$repo}{perms};
        $cur_repo = $repo;
      }
    } elsif (/^($perms_rx) (.* )?= (.+)/) {
      my ($perm, $refs, $user) = trim($1, $2, $3);

      if ($refs =~ /[^ ]/) {
        $errors .= "[line $.] refex permissions are not supported.\n";
      } elsif ($user =~ / /) {
        $errors .= "[line $.] user lists are not supported.\n";
      } elsif ($cur_repo) {
        push @{$config{$cur_repo}{perms}}, [ $user, $perm ];
      } else {
        $errors .= "[line $.] permission definition out of context.\n";
      }
    } elsif (/^\s*(option|config)\s+([^\s]+)?\s*=\s*(.+)/) {
      my($type, $key, $value) = ($1, $2, $3);
      $config{$cur_repo}{$type}{$key} = $value;
    } else {
      $errors .= "[line $.] unknown configuration statement '$_'.\n";
    }
  }
  close CONF;

  die $errors if $errors;

  return \%config;
}

sub dump_rules
{
  my ($config) = @_;

  open CONF, ">$gl_config" or die "can't open rules file: $!.\n";
  print CONF "# This file was automatically generated by devpanel,\n";
  print CONF "# please DO NOT edit this file by hand, use devpanel\n";
  print CONF "# instead or bad things will happen. You've been warned.\n";
  # while (my ($repo, $perms) = each %{$config}{perms})
  foreach my $repo (keys %$config)
  {
    my %repo_r = %{ $config->{$repo} };
    print CONF "\nrepo $repo\n";
    if(exists($repo_r{perms})) {
      for my $perm (@{ $repo_r{perms} })
      {
        printf CONF "    %-6s  =   %s\n", $$perm[1], $$perm[0];
      }
    } 

    foreach my $p (qw( config option )) {
      if(exists($repo_r{$p})) {
        foreach my $key (keys %{ $repo_r{$p} }) {
          printf CONF "    %s %s = %s\n", $p, $key, $repo_r{$p}{$key};
        }
      }
    }
  }

  close CONF;
}

sub check_gitolite_repo
{
  if (-d "$gl_repo_dir/.git") {
    chdir $gl_repo_dir;
    git_clear();
    git_pull();
  } else {
    git_clone();
    chdir $gl_repo_dir;
  }
}

sub update_repo
{
  my ($status, $msg, $push) = (git_status(), @_);
  $push = 1 unless defined($push);

  if ($status or not @_) {
    if ($pretend) {
      if ($msg) {
        info "would have updated with commit message: '$msg'\n";
      } else {
        info "would have pushed.\n";
      }
      info $status;
    } else {
      if ($msg) {
        git_add('.');
        git_commit($msg);
      }
      if ($push) {
        git_push($info?'':'-q');
      }
    }
  } else {
    info "nothing to commit.\n";
  }
}

sub read_key
{
  my ($path) = @_;

  local $\ = '';
  open KEY, "<$path" or die "can't open key file: $!.\n";
  my ($key) = <KEY>;
  close KEY;

  return $key;
}

sub key_fingerprint
{
  my ($key) = @_;
  my ($tmp, $path) = tempfile();

  print $tmp $key;
  close $tmp;
  my ($fingerprint) = run "ssh-keygen -lf $path";
  unlink $path;

  if ($fingerprint =~ /^\w+\s+([0-9a-zA-Z:+]+)/) {
    $fingerprint = $1; 
  } else {
    die "couldn't get key's fingerprint.\n"
  }
  $fingerprint =~ s/://g;

  return $fingerprint;
}

sub success_or_revert
{
  my ($sub) = @_;
  my ($error);

  git_save_revert_point();

  eval { $error = &$sub() };

  if ($error or $@) {
    git_revert_point();
    die $error?$error:$@;
  } else {
    git_delete_revert_point();
    update_repo();
  }
}

sub in_array {
  my($entry, @array) = @_;

  return scalar(grep { $_ eq $entry } @array);
}

sub query_gitolite_rc {
  my($value) = @_;

  my $bin_file = $FindBin::RealBin . '/gitolite';

  if(!open(GITOLITE_EXEC_FH, "$bin_file query-rc $value|")) {
    warn "query_gitolite_rc(): [Error] unable to execute $bin_file: $!\n";
    return undef;
  }

  my $returned_value = <GITOLITE_EXEC_FH>;
  close(GITOLITE_EXEC_FH);
  my $ret = $? >> 8;

  if($ret != 0) {
    warn "query_gitolite_rc(): [Error] unable to query gitolite value $value\n";
    return undef;
  }

  chomp($returned_value);

  return $returned_value;
}

sub set_metadata {
  my($dir, $metadata_str) = @_;

  my $bin_file = $FindBin::RealBin . '/metadata-handler';

  if(!open(METADATA_FH, "|$bin_file $dir")) {
    return "set_metadata(): unable to exec $bin_file: $!\n";
  }

  print METADATA_FH $metadata_str;
  close(METADATA_FH);

  my $ret = $? >> 8;

  if($ret != 0) {
    return "[Error] unable to set metadata for this change\n";
  }

  return undef;
}

sub update_user_cgit_file {
  my($user) = @_;

  my $bin_file = $FindBin::RealBin . '/cgit-gen-user-config';

  my $ret = system($bin_file, $user);

  my $exit_code = $? >> 8;

  if($ret != 0) {
    warn "[Warning] unable update cgitrc for user $user\n";
  }
}

# side-effect functions, calling any of these
# functions will result on a new commit and
# possible a push to the remote repo.
sub set_permissions
{
  my ($config, $repo, $user, $perms, $push) = @_;

  my ($set) = 0;
  if (exists $$config{$repo}) {
    my ($i) = 0;
    for my $perm (@{$$config{$repo}{perms}}) {
      if ($$perm[0] eq $user) {
        if (!defined($perms) or $perms eq '') {
          splice(@{$$config{$repo}{perms}}, $i, 1);
        } else {
          $$perm[1] = $perms;
          $set = 1;
        }
      }
      $i++;
    }
  }
  if (!$set and defined $perms and $perms ne '') {
    push @{$$config{$repo}{perms}}, [ $user, $perms ];
  }

  dump_rules($config);
  update_repo("change permissions for $user on $repo.", $push);
}

sub delete_repo
{
  my ($config, $repo, $push) = @_;

  delete $$config{$repo};

  dump_rules($config);
  update_repo("delete repository '$repo'", $push);
}

sub write_key
{
  my ($user, $key, $push) = @_;
  my ($key_fp) = key_fingerprint($key);
  my ($key_path) = "$gl_keydir/$user\@$key_fp.pub";
  my ($action) = (-e $key_path) ? 'change' : 'add';

  my $key_dir = dirname($key_path);
  if(! -d $key_dir && !mkdir($key_dir)) {
    die "Error: unable to create key directory '$key_dir': $!\n";
  }

  open KEY, ">$key_path" or die "can't open key file '$key_path': $!.\n";
  print KEY $key;
  close KEY;

  update_repo("$action key for user $user", $push);
}

sub delete_user_key
{
  my ($userkey, $push) = @_;
  my ($path);

  if ($userkey =~ /@/) {
    $path = untaint_path("$gl_keydir/$userkey.pub");
    unless (-e $path) {
      die "unkown key '$userkey'.\n";
    }
    git_rm($path);
    update_repo("delete user key '$userkey'", $push);
  } else {
    $path = "$gl_keydir/$userkey@*.pub";
    if (bsd_glob($path)) {
      git_rm(untaint_path($path));
      update_repo("delete all keys for user '$userkey'", $push);
    } else {
      die "unkown user '$userkey'.\n";
    }
  }
}

# git functions
################

sub git_clone
{
  my $git_schema = untaint_path("$ENV{HOME}/repositories/gitolite-admin",
                                 dirname("$ENV{HOME}/repositories/gitolite-admin"));

  # run "git clone $gl_user\@$gl_host:gitolite-admin $gl_repo_dir";
  run "git clone $git_schema $gl_repo_dir";
}

sub git_clear
{
  run 'git reset';
  run 'git checkout .';
  run 'git clean -fd';
}

sub git_add
{
  run 'git add', @_;
}

sub git_commit
{
  my $message = join(' ', @_) || 'commit created by devpanel gitolite manager';
  run "git commit -m '$message'";
}

sub git_pull
{
  run 'git pull';
}

sub git_push
{
  run "git push @_";
}

sub git_status
{
  return run 'git status -s';
}

sub git_rm
{
  run "git rm @_";
}

sub git_reset
{
  run "git reset @_";
}

sub git_tag
{
  run "git tag @_";
}

# helper git functions
#######################

sub git_save_revert_point
{
  git_tag("-f gl-admin-revert-point");
}

sub git_delete_revert_point
{
  git_tag("-d gl-admin-revert-point");
}

sub git_revert_point
{
  git_reset("--hard gl-admin-revert-point");
  git_delete_revert_point();
}

# main
#######

sub usage
{
  my ($name) = $0;
  $name =~ s/^.*\/(\w+)$/$1/;
  return <<eou
usage: $name [ --debug ] [ --verbose ] [ --pretend ]
         [ --git-server <host> ] [ --git-user <user> ]
         <command> <command options>

general options:
  --debug          show debug information.
  --verbose        be verbose
  --pretend        pretend but do not update gitolite repo
  --gl-host        remote gitolite host to administer
  --gl-user        remote gitolite user
  --repo-dir       clone gitolite repo in this local directory

environment variables:
  GL_HOST         remote git host to administer (--git-host)
  GL_USER         remote git user (--git-user)
  GL_REPO_DIR     clone gitolite repo in this directory (--repo-dir)

available commands:
 - setperms [ [ --remove ] <repo> <user> [ <permissions> ] ] | [ --file <file> ]
     sets user's permissions on a given repo. use --remove to remove
     permissions and deny the user access to the repo. use --file to
     read a set of permissions from <file>, one per line. with no
     parameters the command will read from stdin. each line must have
     the following format:
       [:]<repo> <user> [ <perms> ]

     ':' deletes the user's permissions, in which case <perms> can be
     omitted.     

 - addkey <user> [ --key <file> ]
     adds user key in <file>. if <file> is not specified,
     reads the key from stdin (you can also use '-' as
     <file> for the same effect).

 - delkey <user\@fingerprint> | --all <user>
     deletes user key, either an specific key with <user\@fingerprint>
     or _every_ key with --all <user> (as a precaution measure, the
     command won't do anything without --all).

 - setkeys [ --file <file> ]
     bulk adds or deletes users' keys from <file>, one key per line.
     if file is not specified, reads from stdin. each line must have
     the following format:
       add key:
        <user> <ssh formatted public key>
       delete a single key:
        :<user>@<fingerprint>
       delete all keys for a given user:
        :+<user>

 - delrepo [ <repo> ] | [ --file <file> ]
     deletes a repo, either <repo> from the command line or a list
     of repos from <file>, one per line. if neither <repo> nor <file>
     are specified, reads from stdin.

 - add-hook <repo> hook.<type> <hook_script1> [ hook_script2 ] [...]
     adds one or more execution hooks to the specified <repo>.

     The hook types are the usual git hooks, like post-update, post-receive, etc.

 - remove-hook <repo> hook.<type> <hook_script1> [ hook_script2 ] [...]
     removes one or more execution hooks to the specified <repo>

eou
}

Getopt::Long::Configure(qw(require_order));
GetOptions(
  'verbose!'   => \$info,
  'debug'      => \$debug,
  'pretend'    => \$pretend,
  'gl-host=s'  => sub { $gl_host = untaint_var($_[1], 'gl-host'); },
  'gl-user=s'  => sub { $gl_user = untaint_var($_[1], 'gl-user'); },
  'repo-dir=s' => sub { $gl_repo_dir = untaint_var($_[1], 'repo-dir'); },
) or die "Error parsing arguments.\n";

my ($command) = shift;

die usage() if (not $command or $command eq '-h');

# we can show usage for user root, like above
# but this script should not be run by a root user
# root should not manage repos
if($> == 0) {
  die "Error: this script should not be run by root.\n";
}

# these variables are needed to update the gitolite-admin repo without
# requiring ssh access (for the update hooks to execute)
$ENV{GL_USER}   = "devpanel-admin";
$ENV{GL_REPO}   = "gitolite-admin";
$ENV{GL_LIBDIR} = $FindBin::RealBin . "/gitolite.d/lib";
$ENV{GL_BINDIR} = $FindBin::RealBin;

$gl_repo_dir = tempdir("$ENV{HOME}/gitolite-admin.XXXXXXXXXXXXXXXXXXXXX", CLEANUP => 1);
if($@) {
  die "Error: $@\n";
}
$gl_repo_dir = untaint_path($gl_repo_dir, dirname($gl_repo_dir));

$gl_config = "$gl_repo_dir/conf/gitolite.conf";
$gl_keydir = "$gl_repo_dir/keydir";

my $dot_devpanel_dir = "$ENV{HOME}/.devpanel";
my $metadata_dir = "$dot_devpanel_dir/metadata";

my $gl_base_repo_dir = query_gitolite_rc('GL_REPO_BASE');
if(!defined($gl_base_repo_dir)) {
  die "Error: unable to query for gitolite variable GL_REPO_BASE\n";
}

if ($command eq 'setperms') {
  # setperms command
  ###################
  my ($file, $remove, $config, $repo, $user, $perms, $errors);

  if ($#ARGV > -1) {
    GetOptions(
      'remove' => \$remove,
      'file=s' => \$file
    ) or die "Error parsing arguments.\n";
  } else {
    $file = '-';
  }

  if ($file) {
    if ($remove or $#ARGV > -1) {
      die "--file mode can't be combined with other options.\n";
    }
    
    check_gitolite_repo();
    my ($config) = parse_rules();

    my $metadata_r = {};
    my $metadata_str = '';
    success_or_revert(sub {
      open PERMS, "<$file" or die "can't open permissions file.\n";
      print "Reading permission data from " . 
                          ($file eq '-' ? "STDIN" : "file $file") . "...\n";

      my @valid_users;
      while (<PERMS>) {
        next if /^$/;

        unless (/^(:?)\s*($user_rx)\s+($repo_rx)\s*($perms_rx)?$/) {
          $errors .= "[line $.] unrecognized line format.\n";
          next;
        }

        ($remove, $repo, $user, $perms) = ($1, $2, $3, $4);

        if (!$remove and !$perms) {
          $errors .= "[line $.] permissions can't be blank.\n";
          next;
        }

        my $tmp_repo_dir = sprintf("%s/%s.git", $gl_base_repo_dir, $repo);
        if(! -d $tmp_repo_dir) {
          $errors .= "[line $.] dir '$tmp_repo_dir' doesn't exist. ".
                     "Probably repo doesn't exists too";
          next;
        }

        set_permissions($config, $repo, $user, $remove?'':$perms, 0);
        if(!in_array($user, @valid_users)) {
          push(@valid_users, $user);
        }

        my $metadata_op;
        if($remove) {
          $metadata_str = sprintf("rm config:permissions:User:%s:Repo:%s\n",
                                      $user, $repo);
        } else {
          $metadata_str = sprintf("set config:permissions:User:%s:Repo:%s %s\n",
                                    $user, $repo, $perms);
        }

        if(exists($metadata_r->{$repo})) {
          $metadata_r->{$repo} .= $metadata_str;
        } else {
          $metadata_r->{$repo} = $metadata_str;
        }
      }
      close PERMS;

      foreach my $tmp_repo (keys %$metadata_r) {
        if(!$errors) {
          $errors = set_metadata($metadata_dir, $metadata_r->{$tmp_repo});
        }
      }

      if(!$errors) {
        foreach my $tmp_user (@valid_users) {
          # best effort, won't check for errors
          update_user_cgit_file($tmp_user);
        }
      }

      return $errors;
    });

  } else {
    $repo = untaint_var($ARGV[0], 'repository', qr/^($repo_rx)$/);
    $user = untaint_var($ARGV[1], 'user name', qr/^($user_rx)$/);
    $perms = untaint_var($ARGV[2], 'permissions', qr/^($perms_rx)$/);

    check_gitolite_repo();
    my ($config) = parse_rules();
    set_permissions($config, $repo, $user, $perms);

    my $metadata_str = sprintf("set config:permissions:User:%s:Repo:%s %s\n",
                              $user, $repo, $perms);
    set_metadata($metadata_dir, $metadata_str);
    update_user_cgit_file($user);
  }

} elsif ($command eq 'addkey') {
  # addkey command
  #################

  my ($user, $key_file) = (untaint_var(shift), '-');

  die usage() unless $user;
  GetOptions('key=s' => \$key_file) or die "Error parsing arguments.\n";

  my $key = read_key(untaint_path($key_file));
  check_gitolite_repo();
  write_key($user, $key);
  # chdir("/");
} elsif ($command eq 'delkey') {
  # delkey command
  #################

  my ($userkey, $all);
  GetOptions('all', \$all) or die "Error parsing arguments.\n";
  $userkey = untaint_var(shift, "user key", qr/^($user_rx(\@$fp_rx)?)$/);

  if ($userkey !~ /@/ and not $all) {
    die "user without fingerprint given but no --all, aborting.\n";
  }

  check_gitolite_repo();
  delete_user_key($userkey);

  my $username = (split(q'@', $userkey, 2))[0];
  if(index($userkey, '@')) {
    $username = (split(q'@', $userkey, 2))[0];
  } else {
    $username = $userkey;
  }

  my $user_keys_glob  = "$gl_keydir/$username@*.pub";
  my $conf_glob = "$dot_devpanel_dir/config:*:User:$username:*";

  my $metadata_str = '';
  if(!bsd_glob($user_keys_glob) && bsd_glob($conf_glob)) {
    foreach my $entry (bsd_glob($conf_glob)) {
      $metadata_str .= sprintf("rm %s\n", basename($entry));
    }

    set_metadata($metadata_dir, $metadata_str);
  }

} elsif ($command eq 'setkeys') {
  # setkeys command
  ##################

  my ($file) = '-';

  GetOptions('file=s' => \$file) or die "Error parsing arguments.\n";

  check_gitolite_repo();

  success_or_revert(sub {
    my ($remove, $force, $user, $key, $errors);

    open KEYS, "<$file" or die "can't open keys file.\n";
    while (<KEYS>) {
      next if /^$/;

      unless (/^(:?)\s*(\+?)\s*($user_rx(\@$fp_rx)?)(\s+(.+))?$/) {
        $errors .= "[line $.] unrecognized line format.\n";
        next;
      }

      ($remove, $force, $user, $key) = ($1, $2, $3, $5);

      if ($remove) {
        if ($user !~ /@/ and not $force) {
          $errors .= "[line $.] invalid user without fingerprint but no force.\n";
          next;
        }

        eval { delete_user_key($user, 0) };
        $errors .= "[line $.] $@" if ($@);

      } else {
        if (!$key) {
          $errors .= "[line $.] key field can not be blank.\n";
          next;
        }

        if ($user =~ /@/) {
          $errors .= "[line $.] bad user format, fingerprint in add operation.\n";
          next;
        }

        eval { write_key($user, $key, 0) };
        $errors .= "[line $.] $@" if ($@);
      }
    }
    close KEYS;

    return $errors;
  });
} elsif ($command eq 'delrepo') {
  # delrepo command
  ##################

  my ($file, @repos, $errors);

  if ($#ARGV > -1) {
    GetOptions('file=s' => \$file) or die "Error parsing arguments.\n";
  } else {
    $file = '-';
  }

  if (defined $file) {
    if ($#ARGV > -1) {
      die "--file mode can't be combined with other options.\n";
    }
    open REPOS, "<$file" or die "can't open repos file: $!\n";
    @repos = <REPOS>;
    close REPOS;
  } else {
    @repos = @ARGV;
  }

  check_gitolite_repo();
  my ($config) = parse_rules();

  success_or_revert(sub {
    my ($i) = 0;
    for my $repo (@repos) {
      $i++;
      next if ($repo =~ /^$/);

      eval { $repo = untaint_var($repo) };
      if ($@) {
        $errors .= "[line $i] " if (defined $file);
        $errors .= "bad repo name";
        $errors .= " '$repo'" unless (defined $file);
        $errors .= ".\n";
        next;
      }

      delete_repo($config, $repo, 0);

      # remove ssh key files related to the repository
      my $priv_key_file = "$ENV{HOME}/.ssh/id_rsa_dp_repo_$repo";
      my $pub_key_file  = "$ENV{HOME}/.ssh/id_rsa_dp_repo_$repo.pub";
      foreach my $key_file ($priv_key_file, $pub_key_file ) {
        if(-f $key_file) {
          system('shred', '-u', $key_file);
          system('rm', '-f', $key_file); # just in case shred is not installed
        }
      }

      # remove section from ~/.ssh/config referencing the repo key
      system($FindBin::RealBin . '/update-dot-ssh-config', "$ENV{HOME}/.ssh/config",
                                 'remove_section', "git-repo-$repo.*");
    }

    return $errors;
  });
} elsif($command eq 'add-hook') {
  if($#ARGV < 2) {
    die "Usage: $0 add-hook <repo> hook.<type> <hook1> [ hook2 ] ... [ hookN ]\n";
  }

  my $repo = shift(@ARGV);
  if(length($repo) == 0) {
    die "Error: invalid repo name.\n";
  }

  my $hook_type = shift(@ARGV);
  my @valid_hooks = ('receive', 'post-receive', 'update', 'post-update');

  my @new_hooks = @ARGV;
  if(grep { $_ !~ /^[A-Za-z0-9_\.-]+$/; } @new_hooks) {
    die "Error: invalid hook name: $_\n";
  }

  check_gitolite_repo();
  my ($config) = parse_rules();

  my @hooks;
  my $repo_r = $config->{$repo};
  if(exists($repo_r->{option}{$hook_type})) {
    @hooks = split(/\s+/, $repo_r->{option}{$hook_type});
    for(my $i=0; $i <= $#new_hooks; $i++) {
      if(in_array($new_hooks[$i], @hooks)) {
      warn "[Warning] ignoring hook '$new_hooks[$i]', already set...\n";
        splice(@new_hooks, $i, 1);
        $i--;
      }
    }

    if($#new_hooks < 0) {
      warn "[Warning] everything is up to date, no change made.\n";
      exit(0);
    }

    $repo_r->{option}{$hook_type} .= " " . join(" ", @new_hooks);
  } else {
    $repo_r->{option}{$hook_type} = join(" ", @new_hooks);
  }

  dump_rules($config);

  update_repo("added new entries to $hook_type: " . join(", ", @new_hooks), 1);
} elsif($command eq 'remove-hook') {
  if($#ARGV < 2) {
    die "Usage: $0 remove-hook <repo> hook.<type> <hook1> [ hook2 ] ... [ hookN ]\n";
  }

  my $repo = shift(@ARGV);
  if(length($repo) == 0) {
    die "Error: invalid repo name.\n";
  }

  my $hook_type = shift(@ARGV);
  my @valid_hooks = ('receive', 'post-receive', 'update', 'post-update');

  my @rm_hooks = @ARGV;
  if(grep { $_ !~ /^[A-Za-z0-9_\.-]+$/; } @rm_hooks) {
    die "Error: invalid hook name: $_\n";
  }

  check_gitolite_repo();
  my ($config) = parse_rules();

  my @hooks;
  my $repo_r = $config->{$repo};
  if(!exists($repo_r->{option}{$hook_type})) {
    warn "[Warning]: hook $hook_type is not set for repo $repo, no change made.\n";
    exit(0);
  }

  my @confirmed_removed = ();
  @hooks = split(/\s+/, $repo_r->{option}{$hook_type});
  my $orig_n_hooks = $#hooks;
  for(my $i=0; $i <= $#hooks; $i++) {
    if(in_array($hooks[$i], @rm_hooks)) {
      push(@confirmed_removed, $hooks[$i]);
      splice(@hooks, $i, 1);
      $i--;
    }
  }

  if($orig_n_hooks == $#hooks) {
    warn "[Warning] no change made.\n";
    exit(0);
  }

  if($#hooks == -1) {
    if(exists($repo_r->{option}{$hook_type})) {
      delete($repo_r->{option}{$hook_type});
      warn "[Warning]: completely removed hook $hook_type for repo $repo, " .
           "as there's no other script there.\n";
    }
  } else {
    $repo_r->{option}{$hook_type} = join(" ", @hooks);
  }

  dump_rules($config);

  update_repo("removed the following hooks from $hook_type on repo $repo: ".
              join(" ", @confirmed_removed), 1);

} else {
  die "unknown command '$command'.\n";
}

END {
  chdir("/");
}
