#!/bin/bash
if [ -z "$DEVPANEL_HOME" ]; then
  tmp_self=$(readlink -e "${BASH_SOURCE[0]}")
  if [ $? -eq 0 ]; then
    tmp_self_dir="${tmp_self%/*}"
    DEVPANEL_HOME=$(readlink -e "$tmp_self_dir/..")
  fi
  unset tmp_self tmp_self_dir
fi

if [ -f "$DEVPANEL_HOME/bin/utils/jo" -a -x "$DEVPANEL_HOME/bin/utils/jo" ]; then
  hash -p "$DEVPANEL_HOME/bin/utils/jo" jo
fi

# avoid a warning on MacOS X because md5sum doesn't exist
if [ -n "$OSTYPE" ] && [[ "$OSTYPE" =~ ^darwin ]] && hash md5 &>/dev/null; then
  hash -p $(which md5) md5sum
fi

error() {
  local msg="$1"
  local exit_code="${2:-1}"

  [ -n "$msg" ] && echo "Error: $msg" 1>&2

  if [ "$exit_code" == - ]; then
    return 1
  else
    exit $exit_code
  fi
}

wedp_warn() {
  local msg="$1"

  echo "Warning: $msg" 1>&2
}

devpanel_auto_detect_distro() {
  local distro=""

  # can't use local -l below because of systems with bash 3
  local lsb_distro_str="" lsb_distro_raw=""

  if distro=$(get_field_from_os_release ID 2>/dev/null ); then
    printf '%s\n' "$distro"
    return 0
  elif hash lsb_release &>/dev/null; then
    lsb_distro_raw=`lsb_release -si 2>/dev/null`
    lsb_distro_str=`echo -n "$lsb_distro_raw" | tr A-Z a-z`
  fi

  # didn't detect with any of the above, try alternative methods
  if [ -n "$lsb_distro_str" ]; then
    distro="$lsb_distro_str"
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+debian\.org>'; then
    distro=debian
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+ubuntu\.com>'; then
    distro=ubuntu
  elif hash rpm &>/dev/null && rpm -ql centos-release &>/dev/null; then
    distro=centos
  elif hash rpm &>/dev/null && rpm -ql redhat-release-server &>/dev/null; then
    distro=redhat
  elif hash rpm &>/dev/null && rpm -ql owl-hier >/dev/null 2>&1; then
    distro=owl
  elif [[ "$OSTYPE" =~ ^darwin ]]; then
    distro=macosx
  fi

  if [ -n "$distro" ]; then
    echo "$distro"
    return 0
  else
    return 1
  fi
}

devpanel_auto_detect_distro_version() {
  wedp_auto_detect_distro_version "$@"
}

wedp_auto_detect_distro() {
  local distro=""

  # can't use local -l below because of systems with bash 3
  local lsb_distro_str="" lsb_distro_raw=""

  if hash lsb_release &>/dev/null; then
    lsb_distro_raw=`lsb_release -si 2>/dev/null`
    lsb_distro_str=`echo -n "$lsb_distro_raw" | tr A-Z a-z`
  fi

  if [ -n "$lsb_distro_str" ]; then
    distro="$lsb_distro_str"
  elif grep -qis centos /etc/redhat-release; then
    distro=centos
  elif grep -qis "Red Hat Enterprise Linux" /etc/redhat-release; then
    distro=redhat
  elif grep -qis fedora /etc/redhat-release; then
    distro=fedora
  elif rpm -ql owl-hier >/dev/null 2>&1; then
    distro=owl
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+debian\.org>'; then
    distro=debian
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+ubuntu\.com>'; then
    distro=ubuntu
  elif [ -r /etc/gentoo-release ]; then
    distro=gentoo
  elif [[ "$OSTYPE" =~ ^darwin ]]; then
    distro=macosx
  fi

  if [ -n "$distro" ]; then
    echo "$distro"
    return 0
  else
    return 1
  fi
}

wedp_auto_detect_distro_version() {
  local distro="$1"
  local version_str="" version_number=""

  if [ -z "$distro" ]; then
    distro=$(wedp_auto_detect_distro) || return $?
  fi

  if hash lsb_release &>/dev/null; then
    version_number=`lsb_release -sr`
    [ $? -ne 0 ] && return 1
  elif [ "$distro" == "centos" ]; then
      version_str=$(head -1 "/etc/redhat-release" 2>/dev/null)
      [ $? -ne 0 ] && return 1

      # the line below is an invalid syntax on older systems with bash 3
      #if [[ "$version_str" =~ CentOS\ release\ ([0-9]+\.[0-9]+) ]]; then
      # so we have to pipe fgrep and egrep to have a compatible way on all
      # systems
      version_number=`echo "$version_str" | egrep -i 'centos .*release' | \
                        egrep -o '[0-9]+\.[0-9]+(\.[0-9]+)?' 2>/dev/null`
  elif version_str=$(get_field_from_os_release VERSION 2>/dev/null ); then
    version_number=${version_str%%[^0-9.]*}
  fi

  if [ -n "$version_number" ]; then
    echo -n "$version_number"
    return 0
  else
    echo "$FUNCNAME(): unable to detect distro version" 1>&2
    return 1
  fi
}

get_field_from_os_release() {
  local field="$1"
  local file=/etc/os-release
  local output

  output=$(egrep -x -m 1 "^$field=\"?[^\"]+\"?" "$file" )
  if [ $? -ne 0 ]; then
    return 1
  fi

  output=${output#$field=}
  output=${output#\"}
  output=${output%\"}

  printf '%s' "$output"
}

get_linux_distro_string() {
  local os_release_file=/etc/os-release
  local tmp_1 tmp_2
  local distro_str

  if hash lsb_release &>/dev/null; then
    distro_str=$(lsb_release -sd)
  elif [ -f "$os_release_file" ]; then
    tmp_1=$(egrep -x -m 1 'PRETTY_NAME="[^"]+"' /etc/os-release)
    if [ $? -ne 0 -o -z "$tmp_1" ]; then
      echo "$FUNCNAME(): unable to get string from $os_release_file" 1>&2
      return 1
    fi

    tmp_2=${tmp_1#PRETTY_NAME=\"}
    distro_str=${tmp_2%\"}
    return 0
  else
    echo "$FUNCNAME(): don't know how to get info about linux distro" 1>&2
    return 1
  fi

  echo "$distro_str"
}

get_linux_distro_name_pretty() {
  local pretty_name

  if pretty_name=$(get_field_from_os_release PRETTY_NAME 2>/dev/null ); then
    :
  elif hash lsb_release &>/dev/null; then
    pretty_name=$(lsb_release -sd)
  else
    echo "$FUNCNAME(): don't know how to get info about linux distro" 1>&2
    return 1
  fi

  if [ $? -eq 0 ]; then
    printf '%s' "$pretty_name"
  else
    return 1
  fi
}

get_apache_ssl_template_name() {
  local ssl_dir ssl_tmpl
  ssl_tmpl=$(deref_os_prop "$DEVPANEL_HOME" names/apache_vhost_ssl_template )
  if [ $? -eq 0 ]; then
    echo "$ssl_tmpl"
    return 0
  else
    echo "$FUNCNAME(): unable to get the name of the SSL template" 1>&2
    return 1
  fi
}

get_apache_http_port() {
  local apache_config_dir="$DEVPANEL_HOME/config/packages/apache_vhost"
  get_metadata_value "$apache_config_dir" _:Port
}

get_apache_https_port() {
  local ssl_tmpl ssl_dir
  ssl_tmpl=$(get_apache_ssl_template_name) || return $?
  ssl_dir="$DEVPANEL_HOME/config/packages/apache_vhost/templates/$ssl_tmpl"

  get_metadata_value "$ssl_dir" _:Port
}

set_apache_http_port() {
  local port="$1"
  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  elif [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): received a malformed port" 1>&2
    return 1
  fi

  echo "set-local _:Port $port" | "$DEVPANEL_HOME/bin/metadata-handler" -q \
                                    "$DEVPANEL_HOME/config/packages/apache_vhost"
}

set_apache_https_port() {
  local port="$1"
  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  elif [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): received a malformed port" 1>&2
    return 1
  fi

  local ssl_dir ssl_tmpl
  ssl_tmpl=$(get_apache_ssl_template_name) || return $?
  ssl_dir="$DEVPANEL_HOME/config/packages/apache_vhost/templates/$ssl_tmpl"

  echo "set-local _:Port $port" | "$DEVPANEL_HOME/bin/metadata-handler" -q \
                                    "$ssl_dir"
}

print_quoted_variables() {
  local line=""
  local var=""

  for var in "$@"; do
    line=$(declare -p $var)
    line=${line#declare -x}
    echo $line
  done
}

escape_sed() {
  local str="$1"
  local escaped="$str"

  escaped=${escaped//\'/\\\'}
  escaped=${escaped//\*/\\*}
  escaped=${escaped//\;/\\;}
  escaped=${escaped//\[/\\[}
  escaped=${escaped//\]/\\]}
  escaped=${escaped//\\+/+\]}
  escaped=${escaped//\\\?/\?}
  escaped=${escaped//\\\(/\(}
  escaped=${escaped//\\\)/\)}
  escaped=${escaped//\//\\/}
  escaped=${escaped//\&/\\\&}
  escaped=${escaped//$'\n'/\\n}

  echo -n "$escaped"
}

in_array() {
  local value="$1"
  shift

  local v

  [ -z "$*" ] && return 1 # empty list

  for v in "$@"; do
    if [ "$v" == "$value" ]; then
      return 0
    fi
  done

  return 1
}

# the function below is a candidate to be removed as it's much better to use
# variable ${BASH_SOURCE[0]}, though not removing it now because not sure if
# it's being used by other scripts
resolve_local_dir() {
  local base="$1"
  local bin=""
  local bin_path=""
  local dir_name=""

  [ ${#base} -eq 0 ] && return 1

  if [ ${base:0:1} == "/" ]; then
    echo $(dirname "$base")
    return 0
  elif [ ${#base} -gt 2 -a ${base:0:2} == "./" ]; then
    base=${base#./}
    dir_name=$(dirname "$base")
    if [ "$dir_name" == "." ]; then
      echo "$PWD"
    else
      echo "$PWD/$dir_name"
    fi 
    return 0
  elif [ ${#base} -gt 2 -a ${base:0:3} == "../" ]; then
    echo $(dirname "$PWD/$base")
  else
    return 1
  fi 
}

wedp_resolve_link() {
  local source="$1"
  local target=""

  [ -z "$source" ] && return 1

  target=$(readlink -m "$source")
  if [ $? -eq 0 ]; then
    echo "$target"
    return 0
  else
    return 1
  fi
}

wedp_gen_random_str() {
  local length=${1:-40}
  local class=${2:-'A-Za-z0-9'}

  local str=$(head -c $(( $length * 30 )) /dev/urandom | tr -dc "$class")

  if [ ${#str} -lt $length ]; then
    return 1
  else
    echo "${str:0:$length}"
    return 0
  fi
}

gen_12char_random_uuid() {
  local raw hex

  raw=$(head -c 16384 /dev/urandom | md5sum )
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): failed to generate uuid" 1>&2
    return 1
  fi

  hex=${raw%% *}
  if [ -z "$hex" ]; then
    echo "$FUNCNAME(): got an empty hex string" 1>&2
    return 1
  elif [ ${#hex} -ne 32 ]; then
    echo "$FUNCNAME(): got a hex string of ${#hex} characters (not 32)" 1>&2
    return 1
  elif [ ${#hex} -eq 32 ]; then
    echo "${hex:0:8}-${hex:8:4}-${hex:12:4}-${hex:16:4}-${hex:20:12}"
    return 0
  else
    echo "$FUNCNAME(): got an invalid hex string" 1>&2
    return 1
  fi
}

gen_random_str_az_lower() {
  local length=${1:-6}
  local str

  wedp_gen_random_str $length a-z
}

gen_random_str_az09_lower() {
  local length=${1:-6}
  local str

  wedp_gen_random_str $length a-z0-9
}

is_valid_domain_string() {
  local input_str="$1"

  if [[ "$input_str" =~ ^[A-Za-z0-9.-]+$ ]]; then
    return 0
  else
    return 1
  fi
}

generate_username_string_from_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost" 1>&2
    return 1
  fi

  if ! is_valid_vhost_string "$vhost"; then
    echo "$FUNCNAME(): invalid format of vhost name" 1>&2
    return 1
  fi

  local username

  if [ ${#vhost} -le 6 ]; then
    username="w_$vhost"
  else # vhost length greater than 6
    local vhost_str vhost_str_1
    vhost_str="$vhost"
    vhost_str_1="${vhost_str:1}"

    # remove vogals after the 2nd position from $vhost string
    vhost_str="${vhost_str:0:1}${vhost_str_1//[aeiou-]/}"

    if [ -z "$vhost_str" ]; then
      # if it got empty from removing the vogals, then just return the first 6
      # positions of $vhost
      username="w_${vhost:0:6}"
    else
      username="w_${vhost_str:0:6}"
    fi
  fi

  echo "$username"
}

generate_linux_username_for_vhost() {
  local vhost="$1"

  unset _dp_value

  local user_str random_str

  user_str=$(generate_username_string_from_vhost "$vhost")
  if linuxuser_exists "$user_str"; then
    random_str=$(gen_random_str_az_lower 6) || return 1
    user_str="w_$random_str"
    if linuxuser_exists "$user_str"; then
      echo "$FUNCNAME(): unable to generate a unique name" 1>&2
      return 1
    fi
  fi

  _dp_value="$user_str"
  
  [ -n "$_dp_print" ] && printf '%s' "$_dp_value"

  return 0
}

get_vhost_from_linuxuser() {
  local user="${1:-${USER:-$LOGNAME}}"
  local vhost

  if [ -z "$user" ]; then
    echo "$FUNCNAME(): unable to get username information" 1>&2
    return 1
  fi

  local map_link="$lamp__paths__user_vhost_map/$user"
  if [ -L "$map_link" ]; then
    deref_contents "$map_link"
    return $?
  else
    # for servers installed before the $map_link was created
    if [ ${#user} -gt 2 -a "${user:0:2}" == w_ ]; then
      vhost=${user#w_}
      if vhost_exists "$vhost"; then
        echo "$vhost"
        return 0
      fi
    fi
  fi

  return 1
}

get_docroot_from_vhost() {
  local vhost="$1"

  local docroot_dir virtwww_homedir

  get_key_value_from_vhost apache_vhost:_:document_root "$vhost" && \
    docroot_dir="$_dp_value"

  if [ $? -ne 0 ]; then
    # backwards compatibility
    virtwww_homedir=$(deref_os_prop "$DEVPANEL_HOME" apache_virtwww_homedir) \
      || return 1

    docroot_dir="$virtwww_homedir/w_$vhost/public_html/$vhost"
	fi
  
  echo "$docroot_dir"

  return 0
}

get_docroot_from_user() {
  local user="${1:-${USER:-$LOGNAME}}"
  local vhost

  vhost=$(get_vhost_from_linuxuser "$user") || return 1

  get_docroot_from_vhost "$vhost"
}

get_linuxuser_vhost_dir() {
  echo "$lamp__paths__user_vhost_map"
}

get_shell_from_user() {
  local user="${1:-${USER:-$LOGNAME}}"

  if [ -z "$user" ]; then
    echo "$FUNCNAME(): missing username" 1>&2
    return 1
  fi

  local passwd_line shell
  passwd_line=$(getent passwd "$user") || return $?

  shell=$(echo "$passwd_line" | cut -d: -f 7)
  if [ -n "$shell" ]; then
    echo "$shell"
    return 0
  else
    return 1
  fi
}

run_as_user() {
  local -a exec_args_ar=()
  local opt_name
  local shell_bin
  while [ -n "$1" -a "${1:0:1}" == - ]; do
    opt_name="$1"
    case $opt_name in
      --shell)
        if [ -z "$2" ]; then
          echo "$FUNCNAME(): missing arg for --shell option" 1>&2
          return 1
        fi

        shell_bin="$2"
        if [ -f "$2" -a -x "$2" ]; then
          exec_args_ar+=( -s "$shell_bin" )
        else
          echo "$FUNCNAME(): '$2' is not a executable file" 1>&2
          return 1
        fi

        shift 2
        ;;

      --login)
        exec_args_ar+=( -l )
        shift
        ;;
      *)
        echo "$FUNCNAME(): unknown option '$opt_name' received" 1>&2
        return 1
        ;;
    esac
  done

  local user="$1"
  shift

  local -a cmd_ar=( "$@" )

  if hash runuser &>/dev/null; then
    runuser "${exec_args_ar[@]}" -c "${cmd_ar[*]}" "$user"
  else
    su "${exec_args_ar[@]}" -c "${cmd_ar[*]}" "$user"
  fi
}

download_file() {
  local url="$1"
  local temp_file="$2"
  local retries=${3:-3}
  local wait_before_retry=${4:-20}

  if hash curl &>/dev/null; then
    curl -s -S -L --retry $retries --retry-delay $wait_before_retry \
      --cookie /dev/null -o "$temp_file" "$url"
    status=$?
  elif hash wget &>/dev/null; then
    wget -t $retries -w $wait_before_retry -nv -O "$temp_file" "$url"
    status=$?
  fi

  return $status
}

download_file_n_check_sha512() {
  download_file "$@" || return $?

  local file exp_sha sha512 

  file="$2"
  exp_sha="$5"


  sha512=$(calc_sha512_of_file "$file") || return $?

  if [ "$sha512" == "$exp_sha" ]; then
    return 0
  else
    echo "$FUNCNAME(): warning, sha512 '$sha512' doesn't match" \
         "the expected '$exp_sha'" 1>&2
    return 1
  fi
}

get_url_from_cache() {
  local url="$1"
  local retries=${3:-3}
  local wait_before_retry=${4:-5}

  local cache_dir=""
  if [ -n "$DEVPANEL_HOME" ]; then
    cache_dir="$DEVPANEL_HOME/var/seedapps_cache"
  else
    return 1
  fi

  local md5_txt=$(echo -n "$url" | md5sum | cut -d' ' -f 1)

  local cache_link="$cache_dir/$md5_txt:etag"
  if [ ! -L "$cache_link" ]; then
    return 1
  fi

  local tmp_headers_f=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  local resp_raw=""
  resp_raw=$(curl -w "%{http_code}"  -s -I \
    --retry $retries --retry-delay $wait_before_retry \
    -D "$tmp_headers_f" -o /dev/null "$url")
  local curl_st=$?

  code=${resp_raw%%*|}
  if [ $curl_st -ne 0 -o "$code" != "200"  ]; then
    rm -f -- "$tmp_headers_f"
    return 1
  fi

  local etag_raw=$(egrep -i ^ETAG: "$tmp_headers_f")
  if [ $? -ne 0 ]; then
    rm -f -- "$tmp_headers_f"
    return 1
  fi
  local etag_txt="${etag_raw#*: }"
  etag_txt=${etag_txt//[^a-f0-9-]/}

  rm -f -- "$tmp_headers_f"

  local etag_cached=$(readlink "$cache_link")
  if [ $? -ne 0 ]; then
    return 1
  fi

  if [ "$etag_txt" != "$etag_cached" ]; then
    return 1
  fi

  local cached_file="${cache_link%:etag}"
  if [ -s "$cached_file" ]; then
    echo -n "$cached_file"
    return 0
  else
    return 1
  fi
}

download_url_n_cache() {
  local url="$1"
  local temp_file="$2"
  local retries=${3:-3}
  local wait_before_retry=${4:-5}

  local tmp_headers_f=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temp file" 1>&2
    return 1
  fi

  local code="" error_msg="" resp_raw=""

  resp_raw=$(curl -w "%{http_code}" -sSL --retry $retries        \
             --retry-delay $wait_before_retry --cookie /dev/null \
             -D "$tmp_headers_f" -o "$temp_file" "$url" )
  local curl_st=$?

  code=${resp_raw%%*|}
  if [ $curl_st -ne 0 -o "$code" != "200"  ]; then
    rm -f -- "$tmp_headers_f"
    echo "$FUNCNAME(): failed to retrieve url $url" 1>&2
    return 1
  fi

  local etag_raw=$(egrep -i ^ETag: "$tmp_headers_f")
  if [ $? -ne 0 ]; then
    return 0 # won't cache, but it's fine, the file is downloaded
  fi

  local etag=${etag_raw#*: }
  if [ -z "$etag" ]; then
    return 0 # won't cache, but it's fine, the file is downloaded
  fi
  etag=${etag//[^a-f0-9-]/}

  local cache_dir="" mydir="" myfile=""
  if [ -n "$DEVPANEL_HOME" ]; then
    cache_dir="$DEVPANEL_HOME/var/seedapps_cache"
  else
    return 0
  fi 

  local md5_str=$(echo -n "$url" | md5sum | cut -d' ' -f 1)

  if [ -d "$cache_dir" ]; then
    local cache_file="$cache_dir/$md5_str:etag"
    ln -sf "$etag" "$cache_file"
    if [ $? -eq 0 ]; then
      local dest_file="${cache_file%:etag}"

      # the line below does the actual caching
      cp -f "$temp_file" "$dest_file"
    fi
  fi

  return 0
}

translate_url_from_publisher_uri() {
  local uri="$1"
  local publisher url base_url tmp_rel_url

  publisher="${uri%%://*}"

  if [[ ! "$publisher" =~ ^[a-z0-9]+$ ]]; then
    echo "$FUNCNAME(): error, invalid publisher name" 1>&2
    return 1
  fi

  base_url=$(get_base_url_for_publisher "$publisher" ) || return $?

  tmp_rel_url=${uri#*://}
  url="${base_url%/}/$tmp_rel_url"
  if ! [[ "$url" == *.tgz ]]; then
    url+=".tgz"
  fi

  echo "$url"
}

ini_section_get_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`

  sed -n -e "/^\[$section\]/,/^\[/ {
    /^\($key\)[[:space:]]*=.*$/ { s/^$key[[:space:]]*=[[:space:]]*//; p; q 0; }
  } ; $ q 1;" "$file"
}

ini_section_replace_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`
  local value=`escape_sed "$4"`

  local orig_md5 final_md5

  orig_md5=`md5sum "$file"`
  if [[ "$OSTYPE" =~ ^darwin ]]; then
    orig_md5=${orig_md5##* }
  else
    orig_md5=${orig_md5%% *}
  fi

  sed -i -e "/^\[$section\]/,/^\[/ {
    /^\($key\)[[:space:]]*=.*$/ {
      s/^\($key\)[[:space:]]*=.*$/\1 = $value/g;
    }
  }" "$file"

  local status=$?
  [ $status -ne 0 ] && return $status

  final_md5=`md5sum "$file"`
  if [[ "$OSTYPE" =~ ^darwin ]]; then
    final_md5=${final_md5##* }
  else
    final_md5=${final_md5%% *}
  fi

  if [ "$orig_md5" != "$final_md5" ]; then
    return 0 # file changed, success!
  else
    return 1 # file is the same, replace failed
  fi
}

ini_section_add_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`
  local value=`escape_sed "$4"`

  local orig_md5=`md5sum "$file"`
  orig_md5=${orig_md5%% *}

  sed -i -e "/^\[$section\]/ {
    a \
$key = $value
}" "$file"

  local final_md5=`md5sum "$file"`
  final_md5=${final_md5%% *}

  if [ "$orig_md5" != "$final_md5" ]; then
    return 0 # file changed, success!
  else
    return 1 # file is the same, add failed
  fi
}

get_sshkey_fingerprint() {
  local key_text="$1"
  local tmp_file
  local key_line

  tmp_file=`mktemp`
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): could not create temporary file to store the key" 1>&2
    return 1
  fi

  echo "$key_text" >"$tmp_file"
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): could not store the key contents into tmpfile '$tmp_file'" 1>&2
    rm -f "$tmp_file"
    return 1
  fi

  key_line=`ssh-keygen -f "$tmp_file" -l`
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): uname to calculate key fingerprint" 1>&2
    rm -f "$tmp_file"
    return 1
  fi

  rm -f "$tmp_file"

  local key_size key_fingerprint key_input_text
  IFS=" " read key_size fingerprint key_input_text <<< "$key_line"
  if [ -z "$fingerprint" ]; then
    echo "${FUNCNAME[0]}(): got an empty fingerprint" 1>&2
    return 1
  fi

  echo "$fingerprint"
  return 0
}

is_sshkey_in_keyfile() {
  local desired_fp="$1"
  local key_file="$2"
  local fp_list
  local key_line key_mod_size key_fp key_txt

  if ! fp_list=`ssh-keygen -f "$key_file" -l`; then
    echo "${FUNCNAME[0]}(): could not get the list of fingerprints" 1>&2
    return 1
  fi

  while read key_line; do
    IFS=" " read key_size key_fp key_txt <<< "$key_line"
    if [ "$key_fp" == "$desired_fp" ]; then
      return 0
    fi
  done <<< "$fp_list"

  return 1
}

devpanel_download_pkg() {
  local package="$1"
  local version="$2"
  local base_url="$3"
  local tmp_dir="${4:-/tmp}"

  local pkg_url="$base_url/$pkg_n_version.tar.gz"

  local tmp_pkg_dir="$tmp_dir/pkgs"
  if [ ! -d "$tmp_pkg_dir" ] && ! mkdir -m 700 "$tmp_pkg_dir"; then
    echo "$FUNCNAME(): unable to create temp dir '$tmp_pkg_dir'" 1>&2
    return 1
  fi

  if ! download_file "$pkg_url" "$tmp_file"; then
    echo "$FUNCNAME(): unable to download package '$package'" 1>&2
    return 1
  fi
}

devpanel_update_versioned_pkg_version() {
  local package="$1"
  local version="$2"
  local pkg_dir="$3"

  local target_dir="$pkg_dir/$package/$version"
  local target_link="$pkg_dir/$package/current"
  local status

  if [ ! -e "$target_dir" ]; then
    echo "$FUNCNAME(): dir '$target_dir' doesn't seem to exist" 1>&2
    return 1
  fi

  if [ ! -L "$target_link" -a -e "$target_link" ]; then
    echo "$FUNCNAME(): path '$target_link' exists but is not a symbolic link" 1>&2
    return 1
  elif [ -L "$target_link" ]; then
    rm -f "$target_link"
  fi

  ln -s "$version" "$target_link"
  status=$?
  if [ $status -ne 0 ]; then
    echo "$FUNCNAME(): unable to update target link '$target_link'" 1>&2
  fi

  return $status
}

devpanel_update_pkg_link_version() {
  local package="$1"
  local serial="$2"
  local version="$3"
  local system_dir="$4"

  local target_link="$system_dir/config/packages/$package/version"
  local serial_link="$system_dir/config/packages/$package/serial"
  local repo_link="$system_dir/config/packages/$package/repository"

  if [ ! -L "$target_link" -a -e "$target_link" ]; then
    echo "$FUNCNAME(): path '$target_link' exists but is not a symbolic link" 1>&2
    return 1
  elif [ -L "$target_link" ]; then
    rm -f "$target_link"
  fi

  ln -s "$version" "$target_link"
  local status=$?
  if [ $status -ne 0 ]; then
    echo "$FUNCNAME(): unable to update target link '$target_link'" 1>&2
  fi

  ln -sf "$serial" "$serial_link"
  ln -sf "devpanel" "$repo_link"

  return $status
}

calc_md5_str() {
  local str="$1"
  local md5_str=""

  if [[ "$OSTYPE" =~ ^darwin ]]; then
    md5_str=`echo -n "$str" | /sbin/md5`
  else
    md5_str=`echo -n "$str" | md5sum`
  fi

  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get md5sum of string" 1>&2
    return 1
  fi

  if [[ "$OSTYPE" =~ ^darwin ]]; then
    md5_str=${md5_str##* }
  else
    md5_str=${md5_str%% *}
  fi

  echo -n "$md5_str"

  return 0
}

calc_sha512_of_file() {
  local file="$1"

  if [ ! -e "$file" ]; then
    echo "$FUNCNAME(): non-existing path $file" 1>&2
    return 1
  elif [ ! -f "$file" ]; then
    echo "$FUNCNAME(): not a regular file $file" 1>&2
    return 1
  fi

  local line shastr
  line=$(sha512sum "$file")
  if [ $? -eq 0 ]; then
    shastr="${line%% *}"
    if [ -n "$shastr" ]; then
      echo "$shastr"
      return 0
    else
      echo "$FUNCNAME(): got unknown line from sha512sum '$line'" 1>&2
      return 1
    fi
  else
    echo "$FUNCNAME(): unable to calculate, sha512sum returned non-zero" 1>&2
    return 1
  fi
}

devpanel_get_os_version() {
  wedp_auto_detect_distro_version "$@"
}

devpanel_get_os_version_major() {
  local version="$1"
  local major=""

  if [ -z "$version" ]; then
    if ! hash lsb_release &>/dev/null; then
      echo "$FUNCNAME(): error - didn't find lsb_release in PATH" 1>&2
      return 1
    fi

    version=`lsb_release -sr 2>/dev/null`
    if [ -z "$version" ]; then
      echo "$FUNCNAME(): error, unable to get OS version" 1>&2
      return 1
    fi
  fi

  if [[ "$version" =~ ^[0-9]+\. ]]; then
    major=${version%%.*}
  else
    echo "$FUNCNAME(): got string '$version', don't know what to do" 1>&2
    return 1
  fi

  echo -n "$major"
}

devpanel_get_os_version_minor() {
  local version="$1"
  local minor=""

  if [ -z "$version" ]; then
    if ! hash lsb_release &>/dev/null; then
      echo "$FUNCNAME(): error - didn't find lsb_release in PATH" 1>&2
      return 1
    fi

    version=`lsb_release -sr 2>/dev/null`
    if [ -z "$version" ]; then
      echo "$FUNCNAME(): error, unable to get OS version" 1>&2
      return 1
    fi
  fi

  if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then # X.Y.Z
    minor=${version#*.}
    minor=${minor%.*}
  elif [[ "$version" =~ ^[0-9]+\.[0-9]+$ ]]; then # X.Y
    minor=${version#*.}
  else
    echo "$FUNCNAME(): got string '$version', don't know what to do" 1>&2
    return 1
  fi

  echo -n "$minor"
}

deref_contents() {
  local path="$1"

  local value=""

  if [ -L "$path" ]; then
    value=`readlink "$path"`
  elif [ -f "$path" ]; then
    value=`cat "$path"`
  elif [ ! -e "$path" ]; then
    echo "$FUNCNAME(): path doesn't exist $path" 1>&2
    return 1
  else
    echo "$FUNCNAME(): don't know how to de-reference path $path" 1>&2
    return 1
  fi

  echo -n "$value"
}

deref_contents_or_exit() {
  local path="$1"

  deref_contents "$path"
  if [ $? -eq 0 ]; then
    return 0
  else
    echo "Error: unable to de-reference path '$path'" 1>&2
    exit 1
  fi
}

assign_deref_contents_or_exit() {
  local var="$1"
  local path="$2"
  local value=""

  value=`deref_contents "$path"`
  if [ $? -ne 0 -o -z "$value" ]; then
    echo "Error: unable to de-reference path '$path'" 1>&2
    exit 1
  else
    eval $var="$value"
    return $?
  fi
}


deref_os_prop() {
  local base_dir="$1"
  local key_name="$2"

  local os_name="" os_version="" os_major=""
  local base_path="" key_path="" v="" resolved="" local_value=""
  local ver_specific="" ver_major="" os_specific="" devpanel_specific=""

  os_version=`devpanel_get_os_version`
  [ $? -ne 0 ] && return 1

  os_major=`devpanel_get_os_version_major "$os_version"`
  [ $? -ne 0 ] && return 1

  base_path="$base_dir/config/os"

  ver_specific="$base_path/$os_version/$key_name"
  ver_major="$base_path/$os_major/$key_name"
  os_specific="$base_path/$key_name"
  local_value="$base_dir/config/key_value/local/$key_name"
  devpanel_specific="$base_dir/config/key_value/$key_name"

  # check in this order:
  #   config/key_value/local/ -> local custom value
  #   os/<specific_version>   -> for the specific version
  #   os/<os_major>           -> for the specific major version
  #   os/                     -> for the specific distro
  #   config/key_value/       -> generic devPanel convention

  for v in "$local_value" "$ver_specific" "$ver_major" \
           "$os_specific" "$devpanel_specific"; do

    if [ -L "$v" -o -f "$v" ]; then
      key_path="$v"
      break
    fi
  done

  if [ -z "$key_path" ]; then
    echo "$FUNCNAME(): unable to find key $key_name in $base_dir" 1>&2
    return 1
  fi

  deref_contents "$key_path" || return 1
}

deref_os_prop_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_prop "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

assign_deref_os_prop_or_exit() {
  local var="$1"
  local base_dir="$2"
  local key_name="$3"

  local value=""

  value=`deref_os_prop "$base_dir" "$key_name"`
  if [ $? -ne 0 -o -z "$value" ]; then
    echo "Error: unable to de-reference key '$key_name'" 1>&2
    exit 1
  else
    eval $var="$value"
    return $?
  fi
}

get_system_key() {
  local key="$1"

  deref_os_prop "$DEVPANEL_HOME" "$key"
}

deref_os_fs_path() {
  local base_dir="$1"
  local key_name="$2"

  local orig_value="" value="" value_norm="" key_dir=""

  orig_value=`deref_os_prop "$base_dir" "$key_name"`
  [ $? -ne 0 -o -z "$orig_value" ] && return 1

  if [ "${orig_value:0:1}" != "/" ]; then
    key_dir=`dirname "$base_dir/config/os/$key_name"`
    value="$key_dir/$orig_value"
  else
    value="$orig_value"
  fi
  
  # existence of the target path not required
  value_norm=`readlink -m "$value"`

  echo -n "$value_norm"
}

deref_os_fs_path_ex() {
  # the different from deref_os_fs_path() is that this _ex() function
  # requires the file existence
  local base_dir="$1"
  local key_name="$2"

  local orig_value="" value="" value_norm="" key_dir=""

  orig_value=`deref_os_prop "$base_dir" "$key_name"`
  [ $? -ne 0 -o -z "$orig_value" ] && return 1

  if [ "${orig_value:0:1}" != "/" ]; then
    key_dir=`dirname "$base_dir/config/os/$key_name"`
    value="$key_dir/$orig_value"
  else
    value="$orig_value"
  fi

  # requires the existence of the target path
  value_norm=`readlink -e "$value"`
  [ $? -ne 0 ] && return 1

  echo -n "$value_norm"
}


deref_os_fs_path_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_fs_path "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

deref_os_fs_path_ex_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_fs_path_ex "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

assign_deref_os_fs_path_ex_or_exit() {
  local var="$1"
  local base_dir="$2"
  local key_name="$3"

  local value=""

  value=`deref_os_fs_path_ex "$base_dir" "$key_name"`
  if [ $? -eq 0 -a -n "$value" ]; then
    eval $var="$value"
    return $?
  else
    echo "Error: unable to dereference path: $key_name" 1>&2
    exit 1
  fi
}

get_lock_filename() {
  local orig_name="$1"

  if [ -z "$1" ]; then
    echo "$FUNCNAME(): error, missing file name" 1>&2
    return 1
  fi

  local real_path dir_name basename lock_file
  real_path=$(readlink -m "$orig_name")
  if [ $? -ne 0 -o -z "$real_path" ]; then
    return 1
  fi

  dir_name=${real_path%/*}
  basename=${real_path##*/}

  lock_file="$dir_name/.$basename.lock"

  echo "$lock_file"
}

lock_path() {
  local path="$1"
  local sleep_n="${2:-0.1}"
  local -i max_retries="${3:-100}"

  local lock_file=""

  lock_file=$(get_lock_filename "$path") || return 1

  local -i retries=1
  while [ $retries -le $max_retries ]; do
    ln -s "pid:$BASHPID" "$lock_file" 2>/dev/null
    if [ $? -eq 0 ]; then
      printf '%s' "$lock_file"
      return 0
    else
      sleep $sleep_n
    fi
    retries+=1
  done

  wedp_warn "unable to lock path '$path', timed out"
  return 1 # failed
}

unlock_path() {
  local path="$1"
  
  local lock_file=""

  lock_file=$(get_lock_filename "$path")

  if [ ! -L "$lock_file" -a ! -e "$lock_file" ]; then
    wedp_warn "didn't find lock file '$lock_file'"
    return 0
  elif [ ! -L "$lock_file" ]; then
    echo "$FUNCNAME(): path '$lock_file' is not a symlink" 1>&2
    return 1
  fi

  rm -f "$lock_file"
}

rm_rf_safer() {
  local dir="$1"

  if [ -z "$dir" -o ! -d "$dir" ]; then
    return 1
  fi

  local dir_full_path=`readlink -e "$dir"`
  if [ $? -ne 0 -o -z "$dir_full_path" ]; then
    echo "$FUNCNAME(): unable to determine full path of '$dir'" 1>&2
    return 1
  fi

  if [ "$dir_full_path" == "/" ]; then
    echo "$FUNCNAME(): can't use dir as /" 1>&2
    return 1
  fi

  rm -rf "$dir_full_path"
}

get_metadata_value() {
  local dir="$1"
  local key="`basename "$2"`"

  local user_def_path="$dir/local/$key"
  local usual_path="$dir/$key"
  local link_path="" link_value=""

  if [ -L "$user_def_path" ]; then
    link_path="$user_def_path"
  elif [ -L "$usual_path" ]; then
    link_path="$usual_path"
  else
    echo "$FUNCNAME(): didn't find key '$2'" 1>&2
    return 1
  fi

  link_value="`readlink "$link_path"`"
  if [ $? -eq 0 ]; then
    echo "$link_value"
    return 0
  else
    echo "$FUNCNAME(): found, but couldn't read link value on '$link_path'" 1>&2
    return 1
  fi
}

looks_like_an_app_url() {
  local url="$1"

  if [  ${#url} -gt 10 -a "${url:0:7}"   == "http://"           \
     -o ${#url} -gt 10 -a "${url:0:8}"   == "https://"          \
     -o ${#url} -gt 10 -a "${url:0:6}"   == "ftp://"            \
     -o ${#url} -gt  5 -a "${url:0:5}"   == "we://"             \
     -o ${#url} -gt 13 -a "${url:0:13}"  == "webenabled://"     \
     -o ${#url} -gt 11 -a "${url:0:11}"  == "devpanel://"       \
     ]; then

    return 0
  else
    return 1
  fi
}

looks_like_a_publisher_url() {
  local url="$1"

  if ! looks_like_an_app_url "$url"; then
    return 1
  fi

  if [[ "$url" =~ ^(https?|ftp):// ]]; then
    return 1
  elif [[ "$url" =~ ^[a-z0-9]://.+$ ]]; then
    return 0
  fi
}

get_apache_metadata_value() {
  local system_dir="$1"
  local key="$2"

  local apache_config_dir="$system_dir/config/vhosts"
  local vhost
  vhost=$(get_vhost_from_linuxuser) || return $?

  local vhost_conf_dir="$apache_config_dir/$vhost"

  if [ ! -d "$vhost_conf_dir" ]; then
    echo "$FUNCNAME(): missing vhost conf dir $vhost_conf_dir" 1>&2
    return 1
  fi

  get_metadata_value "$vhost_conf_dir" "$key"
}

is_vhost_enabled() {
  local vhost="$1"
  local ns="${2:-v}"
  local var="${ns}__vhost__enabled"

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_valid_port_number() {
  local port="$1"

  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  fi

  if [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): invalid port string" 1>&2
    return 1
  fi

  if [ $port -ge 0 -a $port -le 65535 ]; then
    return 0
  else
    echo "$FUNCNAME(): port out of range, must be within 0-65535" 1>&2
    return 1
  fi
}

is_valid_vhost_string() {
  local string="$1"

  if [ -z "$string" ]; then
    echo "$FUNCNAME(): received an empty vhost string" 1>&2
    return 1
  fi

  local vhost_regex='^[a-z0-9]+[a-z0-9-]+$'

  if [[ "$string" =~ $vhost_regex ]]; then
    return 0
  else
    return 1
  fi
}

vhost_exists() {
  local opt verbose func_name
  while [ -n "$1" -a "${1:0:1}" == - ]; do
    opt="$1"
    case $opt in
      --verbose|-v)
        # display optional verbose error msgs
        verbose=yes
        shift
        ;;

      --errmsg-as-self|-s)
        # display the function name on error msgs as my own name, instead of
        # displaying the name of the function that called me
        func_name="${FUNCNAME[0]}"
        shift
        ;;

      *)
        echo "$FUNCNAME(): unknown option '$opt'" 1>&2
        return 1
        ;;
    esac
  done

  # determine the function name to use on error msgs
  if [ -z "$func_name" ]; then
    if [ -n "${FUNCNAME[1]}" -a "${FUNCNAME[1]}" != main ]; then
      func_name="${FUNCNAME[1]}"
    else
      func_name="${FUNCNAME[0]}"
    fi
  fi

  local test_str="$1"

  if [ -z "$test_str" ]; then
    echo "$func_name(): received an empty vhost string" 1>&2
    return 1
  fi

  if ! is_valid_vhost_string "$test_str"; then
    echo "$func_name(): invalid format of vhost name" 1>&2
    return 1
  fi

  local config_dir="$lamp__paths__vhosts_config_dir/$test_str"
  if [ -d "$config_dir" -a -f "$config_dir/config.ini" ]; then
    return 0
  else
    if [ -n "$verbose" -a "$verbose" == yes ]; then
      echo "$func_name(): vhost doesn't exist" 1>&2
    fi

    return 1
  fi
}

vhost_exists_and_is_enabled() {
  if ! vhost_exists "$@"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  if is_vhost_enabled "$@"; then
    return 0
  else
    echo "$FUNCNAME(): vhost is not enabled" 1>&2
    return 1
  fi
}

linuxuser_exists() {
  local user="$1"

  if getent -- passwd "$user" &>/dev/null; then
    return 0
  else
    return 1
  fi
}

is_distro_updates_enabled() {
  local var="conf__distro__updates_enabled"

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

are_snapshots_enabled_for_vhost() {
  local vhost="$1"
  local freq="$2"
  local var="v__recurring_snapshots_${freq}__enabled"

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

get_snapshot_defs_for_vhost() {
  # returns the definitions of a vhost snapshot in a single line, with
  # elements separated by space. In the format: day hour retention_unit
  # note: daily backups don't have the 'day' field 

  local vhost="$1"
  local freq="$2"
  local _var

  for _var in vhost freq; do 
    if [ -z "${!_var}" ]; then
      echo "$FUNCNAME(): missing $_var" 1>&2
      return 1
    fi
  done

  if ! in_array "$freq" daily weekly monthly; then
    echo "$FUNCNAME(): invalid frequency received" 1>&2
    return 1
  fi

  if ! are_snapshots_enabled_for_vhost "$vhost" "$freq"; then
    echo "$FUNCNAME(): $freq snapshots disabled for vhost $vhost" 1>&2
    return 1
  fi

  local day day_name hour retention_unit
  local key_prefix="config:backup_snapshot:$freq"

  if [ "$freq" != daily ]; then
    day=$(get_vhost_key_value "$key_prefix:day" "$vhost") || return $?
    day_name=$(translate_daynumber_to_name "$day") || return $?
  fi

  hour=$(get_vhost_key_value "$key_prefix:hour" "$vhost") || return $?
  retention_unit=$(get_vhost_key_value "$key_prefix:retention_unit" \
                    "$vhost") || return $?

  local out_str
  if [ "$freq" != daily ]; then
    out_str+="$day_name "
  fi

  out_str+="$hour $retention_unit"

  echo "$out_str"
}

get_devpanel_datadir() {
  local var value
  var="conf__paths__data_dir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_vhost_archives_dir() {
  local vhost="$1"

  local data_dir vhost_archives_dir

  data_dir=$(get_devpanel_datadir ) || return $?

  vhost_archives_dir="$data_dir/vhost_archives/$vhost"

  echo "$vhost_archives_dir"

  return 0
}

get_apache_service_name() {
  local var value
  var="lamp__apache__service_name"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_vhost_template() {
  local var value
  var="lamp__apache_templates__default_vhost"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_vhosts_homedir() {
  local var value
  var="lamp__apache_paths__virtwww_homedir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_group_name() {
  local var value
  var="lamp__apache__group"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_main_config_dir() {
  local var value
  var="lamp__apache_paths__base_dir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_virtwww_config_dir() {
  local var value
  var="lamp__apache_paths__vhosts_include_dir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_virtwww_log_dir() {
  local var value
  var="lamp__apache_paths__vhost_logs_dir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_global_includes_dir() {
  local var value
  var="lamp__apache_paths__includes_dir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_tools_base_url_template() {
  local var value
  var="lamp__apache_url_tmpls__tools_base"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_template_url_for_archive_download() {
  local var value
  var="lamp__apache_url_tmpls__archive_download"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_apache_exec_group_name() {
  local var value
  var="lamp__apache__exec_group"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_mysql_instances_homedir() {
  local var value
  var="lamp__mysql_paths__instances_homedir"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_packages_url_base() {
  local var value
  var="conf__packages__url_base"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_packages_metadata_url() {
  local var value
  var="conf__packages__metadata_url"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
  else
    return 1
  fi
}

get_path_of_chcgi() {
  local test_bin="$DEVPANEL_HOME/compat/suexec/chcgi"
  if [ -f "$test_bin" -a -x "$test_bin" ]; then
    echo "$test_bin"
    return 0
  else
    return 1
  fi
}

get_vhost_archive_template_str() {
  local var value
  var="conf__template_strings__vhost_archive"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_admin_apps_base_url() {
  local var value
  var="conf__template_urls__admin_apps"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_domain_of_autogenerated_hostnames() {
  local var value
  var="lamp__apache_vhosts__auto_gen_domain"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_git_vhost_template() {
  local var value
  var="lamp__apache_templates__git_vhost"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

get_htpasswd_vhost_template() {
  local var value
  var="lamp__apache_templates__htpasswd"
  value="${!var}"
  
  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi
}

set_s3_options() {
  save_opts_in_devpanel_config "$@"
}

write_s3cfg() {
  local file="$1"
  shift

  if [ "$file" == @ ]; then
    file=/etc/devpanel/provisioners/aws/.s3cfg/default
  fi

  if [ ! -f "$file" ]; then
    touch "$file"
    chmod 600 "$file"
  fi

  write_ini_file "$file" "$@"
}

set_s3_bucket() {
  local bucket="$1"

  save_opts_in_devpanel_config "s3.bucket_name = $bucket" \
    "s3.upload_files = yes"
}

disable_s3_global_uploads() {
  save_opts_in_devpanel_config "s3.upload_files = no"
}

is_global_s3_uploads_enabled() {
  if [ -n "$conf__s3__upload_files" -a "$conf__s3__upload_files" == "yes" ]; then
    return 0
  else
    return 1
  fi
}

get_global_s3_bucket() {
  if [ -n "$conf__s3__bucket_name" ]; then
    echo "$conf__s3__bucket_name"
    return 0
  else
    return 1
  fi
}

get_global_s3_base_addr_template() {
  if [ -n "$conf__s3__baseaddr_vhost_tmpl" ]; then
    echo "$conf__s3__baseaddr_vhost_tmpl"
    return 0
  else
    return 1
  fi
}

get_s3_upload_speed_limit() {
  if [ -n "$conf__s3__upload_speed_limit" ]; then
    echo "$conf__s3__upload_speed_limit"
    return 0
  else
    return 1
  fi
}

get_s3_url_base_for_vhost() {
  local vhost="$1"

  local bucket_name virtwww_domain tmpl_url
  local url var

  tmpl_url=$(get_global_s3_base_addr_template ) || return $?
  virtwww_domain=$(get_server_base_domain )     || return $?
  bucket_name=$(get_global_s3_bucket )          || return $?

  url="$tmpl_url"
  for var in bucket_name virtwww_domain vhost ; do
    url=${url//@$var@/${!var}}
    url=${url//./-}
  done

  local -i url_len=${#url}
  if [ "${url:$(( $url_len - 1 ))}" != / ]; then
    url+="/"
  fi

  echo "$url"
}

get_aws_cluster_region() {
  deref_os_prop "$DEVPANEL_HOME" aws_cluster_region
}

get_aws_cluster_stack_id() {
  deref_os_prop "$DEVPANEL_HOME" aws_cluster_stack_id
}

get_aws_cdn_endpoint() {
  deref_os_prop "$DEVPANEL_HOME" aws_cdn_endpoint
}

get_template_str_for_recurring_archive_snapshot() {
  local frequency="$1"

  deref_os_prop "$DEVPANEL_HOME" vhost_snapshot_${frequency}_template_str
}

enable_webenabled_backwards_compat() {
  save_opts_in_lamp_config "apache.webenabled_backwards_compat = yes"
}

disable_webenabled_backwards_compat() {
  save_opts_in_lamp_config "apache.webenabled_backwards_compat = no"
}

is_webenabled_backwards_compat_enabled() {
  local var
  var="lamp__apache__webenabled_backwards_compat"
  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

disable_package_updates() {
  save_opts_in_devpanel_config "packages.updates_enabled = no"
}

enable_package_updates() {
  save_opts_in_devpanel_config "packages.updates_enabled = yes"
}

is_package_updates_disabled() {
  local var
  var=conf__packages__updates_enabled
  if [ -n "${!var}" -a "${!var}" == no ]; then
    return 0
  else
    return 1
  fi
}

date_placeholders() {
  local template_str="$1"
  local ref_date="${2:-now}"

  if [ -n "$ref_date" ] && ! [[ "$ref_date" =~ ^[A-Za-z0-9\ -]+$ ]]; then
    echo "$FUNCNAME(): invalid ref_date" 1>&2
    return 1
  fi

  # local fmt_str='+%d %b %m %Y %H %M'
  local fmt_str='+%d %b %m %Y %H %M %W %w %s %j %a %x %X %Z %z'

  # local day month monthn year hour minute
  local day month_name month_number year hour minute \
        week_year day_week epoch day_year day_name   \
        locale_date locale_time timezone_abrev timezone_num

  IFS=" " read day month_name month_number year hour minute \
               week_year day_week epoch day_year day_name   \
               locale_date locale_time timezone_abrev timezone_num \
            <<< $(date -d "$ref_date" "$fmt_str")

  local date_str

  date_str="$template_str"
  date_str=${date_str//@day@/"$day"}
  date_str=${date_str//@month_name@/"$month_name"}
  date_str=${date_str//@month_number@/"$monthn"}
  date_str=${date_str//@year@/"$year"}
  date_str=${date_str//@hour@/"$hour"}
  date_str=${date_str//@minute@/"$minute"}
  date_str=${date_str//@week_year@/"$week_year"}
  date_str=${date_str//@day_week@/"$day_week"}
  date_str=${date_str//@epoch@/"$epoch"}
  date_str=${date_str//@day_year@/"$day_year"}
  date_str=${date_str//@day_name@/"$day_name"}
  date_str=${date_str//@locale_date@/"$locale_date"}
  date_str=${date_str//@locale_time@/"$locale_time"}
  date_str=${date_str//@timezone_abrev@/"$timezone_abrev"}
  date_str=${date_str//@timezone_num@/"$timezone_num"}

  # auxiliary formats for breviety
  date_str=${date_str//@aux_date_str@/$month_name-$day-$year}

  printf '%s' "$date_str"
}

get_php_version() {
  if hash php-config &>/dev/null; then
    php-config --version
    return $?
  elif hash php &>/dev/null; then
    local tmp_str=$(php -v | egrep -o 'PHP [0-9]\.[0-9]+\.[0-9]+')
    if [ $? -ne 0 -o -z "$tmp_str" ]; then
      echo "$FUNCNAME(): unable to get version string from php command" 1>&2
      return 1
    fi
    local junk ver_str 
    IFS=" " read junk ver_str <<< "$tmp_str"

    echo -n "$ver_str"
    return 0
  fi

  echo "$FUNCNAME(): php doesn't seem to be installed" 1>&2
  return 1
}

run_verbose() {
    echo "Running command: $@"
    "$@"
}

is_valid_mysql_db_or_table_name() {
  local str="$1"

  [ -z "$str" ] && return 1

  if [[ "$str" =~ ^[A-Za-z0-9_]+$ ]]; then
    return 0
  else
    return 1
  fi
}

is_mysql_engine_supported() {
  local engine="$1"

  local sql_tmpl='SELECT * FROM ENGINES WHERE ENGINE = "%s" 
                  AND SUPPORT IN("YES", "DEFAULT");'

  sql_line=$(printf "$sql_tmpl" "$engine")

  local output=""
  output=$(mysql -BN -D information_schema -e "$sql_line")
  if [ $? -ne 0 ]; then
    return 1
  fi

  if [ -n "$output" ]; then
    return 0
  else
    return 1
  fi
}

escape_quotes() {
  local orig="$1"
  local new="$orig"

  new=${new//\\/\\\\}
  new=${new//\'/\\\'}
  new=${new//\"/\\\"}

  printf '%s' "$new"
}

set_lamp_virtwww_domain() {
  local domain="$1"

  save_opts_in_lamp_config "apache vhosts.virtwww_domain = $domain"
}

get_vhost_base_domain() {
  # returns the real base domain of a vhost
  local vhost="$1"

  if [ -n "$v__vhost__base_domain" ]; then
    echo "$v__vhost__base_domain"
    return 0
  else
    return 1
  fi
}

get_vhost_default_hostname() {
  # returns the default hostname of the vhost
  # (i.e the one used on ServerName and in the app's config

  local vhost="$1"

  if [ -n "$v__vhost__server_name" ]; then
    echo "$v__vhost__server_name"
    return 0
  else
    return 1
  fi
}

is_ssl_enabled_on_vhost() {
  local vhost="$1"
  local var=v__ssl__enabled

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_lets_encrypt_enabled_for_vhost() {
  local vhost="$1"

  local enabled

  if [ -n "$v__ssl__enabled" -a \
          "$v__ssl__enabled" == yes -a -n "$v__ssl__type" -a \
          "$v__ssl__type" == lets-encrypt ]; then

    return 0
  else
    return 1
  fi
}

get_main_url_of_vhost() {
  local vhost="$1"
  local url domain

  if is_ssl_enabled_on_vhost "$vhost"; then
    url="https://"
  else
    url="http://"
  fi

  domain=$v__vhost__server_name

  url+="$domain"
  url+="/"

  echo "$url"
}

get_server_base_domain() {
  local system_dir="${1:-$DEVPANEL_HOME}"
  local domain

  if [ -n "$lamp__apache_vhosts__virtwww_domain" ]; then
    echo "$lamp__apache_vhosts__virtwww_domain"
    return 0
  else
    return 1
  fi
}

format_hostname_internal() {
  local test_hostname="$1"
  local force_subdomain="${2:-0}"
  local base_domain="$3"

  if [ -z "$base_domain" ]; then
    base_domain=$(get_server_base_domain) || return $?
  fi

  local test_host_stripped="" final_hostname="" has_dot=""

  if [[ "$test_hostname" =~ \. ]]; then
   has_dot=1
  fi

  # remove the server hostname from the end of name
  if [ "${test_hostname: -1}" == "." ]; then
    test_host_stripped=${test_hostname%.$base_domain.}
  else
    test_host_stripped=${test_hostname%.$base_domain}
  fi

  if [ "$force_subdomain" == "1" ]; then
    if [ "${test_hostname: -1}" == "." ]; then
      # $len_minus_one is a workaround for older bash versions that don't know
      # negative lengths (e.g. CentOS 6.5 and previous)
      local len_minus_one=$(( ${#test_hostname} - 1 ))
      final_hostname="${test_host_stripped:0:$len_minus_one}"
    else
      final_hostname="$test_host_stripped"
    fi
  else
    if [ "$test_host_stripped" != "$test_hostname" ]; then
      # had the server name successfully stripped, so it's a subdomain
      final_hostname="$test_host_stripped"
    elif [ "${test_hostname: -1}" == "." ]; then
      # if the hostname ends with a dot, then take it as fully defined
      final_hostname="$test_hostname"
    elif [ -n "$has_dot" ]; then
      # hostname doesn't end with a dot, but has a dot in the name
      # so let's guess it's a full domain
      final_hostname="$test_hostname."
    else
      # hostname doesn't end with a dot, doesn't have a dot
      # consider it a sub domain of the default server domain
      final_hostname="$test_hostname"
    fi
  fi

  echo -n "$final_hostname"
}

get_real_hostname() {
  local hostname="$1"

  local host_fmt="" server_base_domain=""

  if [ "${hostname: -1}" == "." ]; then
    # $len_minus_one is a workaround for older bash versions that don't know
    # negative lengths (e.g. CentOS 6.5 and previous)
    local len_minus_one=$(( ${#hostname} - 1 ))
    host_fmt="${hostname:0:$len_minus_one}" # remove the last dot
  else
    server_base_domain=$(get_server_base_domain) || return $?   
    host_fmt="$hostname.$server_base_domain"
  fi

  echo -n "$host_fmt"
}

get_list_of_vhosts() {
  local vhost_config_dir="$lamp__paths__vhosts_config_dir"
  local vhost vhost_dir
  local -a vhosts_ar=()

  if [ ! -d "$vhost_config_dir" ]; then
    echo "$FUNCNAME(): missing config dir $vhost_config_dir" 1>&2
    return 1
  fi

  for vhost_dir in "$vhost_config_dir/"*; do
    [ ! -d "$vhost_dir" ] && continue
    vhost=${vhost_dir##*/}
    vhosts_ar+=( "$vhost" )
  done

  if [ ${#vhosts_ar[*]} -le 0 ]; then
    return 0
  else
    echo "${vhosts_ar[@]}"
  fi
}

get_list_of_local_vhosts() {
  get_list_of_vhosts "$@"
}

get_list_of_enabled_vhosts() {
  local -a vhosts_ar=() en_vhosts_ar=()
  local vhost ini_file

  vhosts_ar=( $(get_list_of_vhosts) )

  if [ ${#vhosts_ar[*]} -gt 0 ]; then
    for vhost in "${vhosts_ar[@]}"; do
      load_vhost_config "$vhost" tmp_vhost || continue
      if [ "$tmp_vhost__vhost__enabled" == yes ]; then
        en_vhosts_ar+=( "$vhost" )
      fi
    done
  fi

  if [ ${#en_vhosts_ar[*]} -gt 0 ]; then
    echo "${en_vhosts_ar[@]}"
  fi

  return 0
}

get_vhost_with_hostname() {
  local hostname="$1"

  local tst_vhost

  for tst_vhost in $(get_list_of_vhosts); do
    load_vhost_config "$tst_vhost" tmp_vhost || continue

    if is_word_in_string "$hostname" "$tmp_vhost__vhost__domains"; then
      echo "$tst_vhost"
      return 0
    fi
  done

  cleanup_namespace tmp_vhost

  return 1 # not found in any vhost
}

get_hostnames_from_vhost() {
  local vhost="$1"

  local vhost_conf_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  local base_domain default_domain
  local tmp_link tmp_name tmp_fmt_name 
  local -a hosts_ar=()

  base_domain=$(get_vhost_base_domain "$vhost") || return $?

  default_domain=$(get_vhost_default_hostname "$vhost") || return $?

  hosts_ar+=( "$base_domain" )
  if [ "$base_domain" != "$default_domain" ]; then
    hosts_ar+=( "$default_domain" )
  fi

  for tmp_link in "$vhost_conf_dir/apache_vhost:0:_:ServerAlias:"*; do
    if [ ! -L "$tmp_link" ]; then
      continue
    fi

    # apache_vhost:0:_:ServerAlias:domain.com.
    tmp_name=${tmp_link##*:}
    tmp_fmt_name=$(get_real_hostname "$tmp_name") || return $?

    if [ "$tmp_fmt_name" == "$base_domain" ]; then
      continue
    fi

    hosts_ar+=( $tmp_fmt_name )
  done

  local IFS=$'\n'
  echo "${hosts_ar[*]}"
}

has_custom_domain() {
  local vhost="$1"
  local hosts_ar=()

  local vhosts_basedomain
  vhosts_basedomain=$(get_server_base_domain ) || return $?

  hosts_ar=( $(get_hostnames_from_vhost "$vhost") ) || return $?

  local tmp_host
  for tmp_host in "${hosts_ar[@]}"; do
    if [[ ! "$tmp_host" == *.$vhosts_basedomain ]]; then
      return 0
    fi
  done

  return 1
}

translate_archive_placeholders() {
  local orig="$1"
  local final

  # uses globals $sys_data_dir $vhost_data_dir $vhost $period
  #              $archive_template_str $removed_vhosts_dir

  final="$orig"

  [ -n "$archive_template_str" ] && \
    final=${final//@archive_template_str@/$archive_template_str}

  [ -n "$sys_data_dir" ]   && final=${final//@system_data_dir@/$sys_data_dir}

  [ -n "$vhost_archive_dir" ] && \
    final=${final//@vhost_archive_dir@/$vhost_archive_dir}

  [ -n "$removed_vhosts_dir" ] && \
    final=${final//@removed_vhosts_dir@/$removed_vhosts_dir}

  [ -n "$vhost" ]        && final=${final//@vhost@/$vhost}
  [ -n "$frequency" ]    && final=${final//@frequency@/$frequency}

  final=${final//@random_int@/$RANDOM}

  final=$(date_placeholders "$final") || return 1

  echo "$final"
}

get_recurring_backup_property() {
  local period="$1"
  local unit="$2"
  local vhost="$3"

  local vhost_config_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  local link="$vhost_config_dir/config:backup_snapshot:$period:$unit"

  deref_contents "$link"
}

get_vhost_key_value() {
  local key="$1"
  local vhost="$2"
  local value=""

  if [ -z "$vhost" ]; then
    if ! vhost=$(get_vhost_from_linuxuser); then
      echo "$FUNCNAME(): missing vhost, please specify it" 1>&2
      return 1
    fi
  fi

  is_valid_vhost_string "$vhost" || return $?

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local key_link="$DEVPANEL_HOME/config/vhosts/$vhost/$key"

  deref_contents "$key_link"
}

enable_long_vhost_names() {
  save_opts_in_lamp_config "apache.enable_long_vhost_names = yes"
}

is_longer_vhost_names_enabled() {
  local var value
  var=lamp__apache__enable_long_vhost_names
  value=${!var}

  if [ -n "$value" -a "$value" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_valid_php_version_string() {
  local str="$1"

  if [ -z "$str" ]; then
    echo "$FUNCNAME(): missing version string argument" 1>&2
    return 1
  fi

  if [[ "$str" == [1-9].[0-9] ]]; then
    return 0
  else
    echo "$FUNCNAME(): invalid format specified for PHP version" 1>&2
    return 1
  fi
}

set_php_version_metadata_for_vhost() {
  local vhost="$1"
  local version="$2"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost argument" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  save_opts_in_vhost_config "$vhost" "php.version = $version"
}

rm_php_version_metadata_for_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost argument" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi
 
  save_opts_in_vhost_config "$vhost" "- php.version"
}

is_known_seedapp_subsystem() {
  local name="${1##*/}"
  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing subsystem name" 1>&2
    return 1
  fi

  local app_dir="$DEVPANEL_HOME/bin/seeds/$name"

  if [ -d "$app_dir" ]; then
    return 0
  else
    return 1
  fi
}

has_min_path_matches() {
  local t_dir="$1"
  local -i n_min_matches=$2
  local -i n_matches=0

  if [ $# -lt 3 ]; then
    echo "$FUNCNAME(): error - missing arguments" 1>&2
    return 1
  fi

  shift 2

  local t_path

  while [ -n "$1" ]; do
    t_path="$t_dir/$1"
    if [ -e "$t_path" ]; then
      n_matches+=1
    fi
    shift

    if [ $n_matches -ge $n_min_matches ]; then
      return 0
    fi
  done

  return 1
}

detect_app_type_on_dir() {
  local t_dir="$1"
  local min_matches=3

  local app_type

  local -a d6_paths=( includes/bootstrap.inc modules index.php update.php )
  local -a d7_paths=( includes/bootstrap.inc modules index.php update.php )
  local -a d8_paths=( core/lib/Drupal autoload.php modules index.php update.php )
  local -a wordpress_v4_paths=( wp-config.php wp-content wp-includes \
                                      wp-login.php wp-admin )


  if has_min_path_matches "$t_dir" $min_matches "${d6_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${d7_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${d8_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${wordpress_v4_paths[@]}"; then
    app_type=wordpress
  else
    return 1
  fi

  if [ -n "$app_type" ]; then
    echo -n "$app_type"
    return 0
  else
    return 1
  fi
}

guess_subsystem_from_app_archive() {
  local archive="$1"
  local tmp_dir subsystem _sub_dir _tmp_subsystem
  local db_dir db_dir_tst db_ext db_dir_1 db_dir_2

  if ! tmp_dir=$(mktemp -d); then
    echo "$FUNCNAME(): unable to create temp dir" 1>&2
    return 1
  fi

  db_dir_1="db"
  db_dir_2="./db"
  for db_dir_tst in "$db_dir_1" "$db_dir_2"; do
    if tar -ztf "$archive" --no-recursion "$db_dir_tst" &>/dev/null; then
      db_dir="$db_dir_tst"
      db_ext="$db_dir/databases"
      if tar -zxf "$archive" -C "$tmp_dir" "$db_ext"; then
        break
      else
        echo "$FUNCNAME(): failed to extract '$db_ext' from '$archive'" 1>&2
        return 1
      fi
    fi
  done

  if [ -z "$db_dir" ]; then
    echo "$FUNCNAME(): didn't find database dir on archive '$archive'" 1>&2
    return 1
  fi

  for _sub_dir in "$DEVPANEL_HOME/bin/seeds/"*; do
    if [ ! -d "$_sub_dir" ]; then
      continue
    fi

    _tmp_subsystem=${_sub_dir##*/}
    if is_known_seedapp_subsystem "$_tmp_subsystem"; then
      if fgrep -qx "$_tmp_subsystem" "$tmp_dir/db/databases"; then
        subsystem="$_tmp_subsystem"
        break
      fi
    fi
  done

  rm -rf "$tmp_dir"

  if [ -n "$subsystem" ]; then
    echo "$subsystem"
    return 0
  else
    return 1
  fi
}

translate_dayname_to_number() {
  local name="${1,,}"
  local n

  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing name" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $name in
    sunday|sun)
      n=0
      ;;
    monday|mon)
      n=1
      ;;
    tuesday|tue)
      n=2
      ;;
    wednesday|wed)
      n=3
      ;;
    thursday|thu)
      n=4
      ;;
    friday|fri)
      n=5
      ;;
    saturday|sat)
      n=6
      ;;
    *)
      echo "$FUNCNAME(): unknown day" 1>&2
      return 1
      ;;
  esac

  echo "$n"
}

translate_daynumber_to_name() {
  local number="$1"
  local name

  if [ -z "$number" ]; then
    echo "$FUNCNAME(): missing parameter number" 1>&2
    return 1
  elif [[ "$number" == [0-6] ]]; then
    : # ok
  else
    echo "$FUNCNAME(): invalid number, needs to be between 0 and 6" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $number in
    0)
      name=sunday
      ;;
    1)
      name=monday
      ;;
    2)
      name=tuesday
      ;;
    3)
      name=wednesday
      ;;
    4)
      name=thursday
      ;;
    5)
      name=friday
      ;;
    6)
      name=saturday
      ;;
    *)
      echo "$FUNCNAME(): don't know how to translate '$number' to name" 1>&2
      return 1
      ;;
  esac

  echo "$name"
}

dump_vhost_mysql_db() {
  local vhost="$1"
  local database="$2"

  if ! "$DEVPANEL_HOME/libexec/check-vhost-name" archive "$vhost"; then
    return 1
  fi

  local temp_my_cnf
  local mysql_host mysql_port mysql_user mysql_pass
  mysql_host=$(get_vhost_key_value app:0:_:db_host "$vhost" 2>/dev/null)
  mysql_port=$(get_vhost_key_value app:0:_:db_port "$vhost" 2>/dev/null)
  mysql_user=$(get_vhost_key_value app:0:_:db_user "$vhost" 2>/dev/null)
  mysql_pass=$(get_vhost_key_value app:0:_:db_password "$vhost" 2>/dev/null)
  
  if [ -z "$database" ]; then
    database=$(get_vhost_key_value app:0:_:db_name "$vhost" 2>/dev/null)
    if [ $? -ne 0 ]; then
      echo "$FUNCNAME(): unable to get database name for vhost $vhost" 1>&2
      return 1
    fi
  fi

  if ! temp_my_cnf=$(mktemp); then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  echo "
client.host = $mysql_host
client.port = $mysql_port
client.user = $mysql_user
client.password = $mysql_pass
" | "$DEVPANEL_HOME/bin/update-ini-file" -q -c "$temp_my_cnf"
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to write ini file '$temp_my_cnf'" 1>&2
    rm -f "$temp_my_cnf"
    return 1
  fi

  local st

  mysqldump --defaults-extra-file="$temp_my_cnf" "$database"
  st=$?

  rm -f "$temp_my_cnf"

  return $st
}

translate_dayname_to_number() {
  local name="${1,,}"
  local n

  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing name" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $name in
    sunday|sun)
      n=0
      ;;
    monday|mon)
      n=1
      ;;
    tuesday|tue)
      n=2
      ;;
    wednesday|wed)
      n=3
      ;;
    thursday|thu)
      n=4
      ;;
    friday|fri)
      n=5
      ;;
    saturday|sat)
      n=6
      ;;
    *)
      echo "$FUNCNAME(): unknown day" 1>&2
      return 1
      ;;
  esac

  echo "$n"
}

translate_daynumber_to_name() {
  local number="$1"
  local name

  if [ -z "$number" ]; then
    echo "$FUNCNAME(): missing parameter number" 1>&2
    return 1
  elif [[ "$number" == [0-6] ]]; then
    : # ok
  else
    echo "$FUNCNAME(): invalid number, needs to be between 0 and 6" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $number in
    0)
      name=sunday
      ;;
    1)
      name=monday
      ;;
    2)
      name=tuesday
      ;;
    3)
      name=wednesday
      ;;
    4)
      name=thursday
      ;;
    5)
      name=friday
      ;;
    6)
      name=saturday
      ;;
    *)
      echo "$FUNCNAME(): don't know how to translate '$number' to name" 1>&2
      return 1
      ;;
  esac

  echo "$name"
}

bytes_to_human() {
  local -i n_bytes="$1"
  local n_bytes_human unit

  local -i kb=1024 mb=$(( 1024 * 1024 )) gb=$(( 1024 * 1024 * 1024 ))

  if [ -z "$n_bytes" ] || ! [[ "$n_bytes" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  if [ $n_bytes -gt $gb ]; then
    unit='gb'
  elif [ $n_bytes -gt $mb ]; then
    unit='mb'
  elif [ $n_bytes -gt $kb ]; then
    unit='kb'
  fi

  n_bytes_human=$(echo "scale = 2; $n_bytes / ${!unit}" | bc -l)

  echo -n "$n_bytes_human ${unit^^}"
}

get_ssl_cert_path_from_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    return 1
  fi

  if ! is_ssl_enabled_on_vhost "$vhost"; then
    echo "$FUNCNAME(): SSL not enable for vhost $vhost" 1>&2
    return 1
  fi

  local cert_dir cert_file

  cert_dir="$DEVPANEL_HOME/config/os/pathnames/etc/ssl/certs"
  cert_file="$cert_dir/$vhost.default_ssl.crt"

  echo "$cert_file"
  return 0
}

get_field_from_ssl_cert_file() {
  local field="$1"
  local file="$2"

  if [ -z "$field" ]; then
    echo "$FUNCNAME(): missing field argument" 1>&2
    return 1
  elif [ -z "$file" ]; then
    echo "$FUNCNAME(): missing file argument" 1>&2
    return 1
  elif [[ ! "$field" =~ ^[A-Za-z0-9]+$ ]]; then
    echo "$FUNCNAME(): received field in an invalid format" 1>&2
    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "$FUNCNAME(): missing file '$file'" 1>&2
    return 1
  fi

  local field_txt

  field_txt=$(openssl x509 -noout -"$field" -in "$file" 2>/dev/null)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get field from cert" 1>&2
    return 1
  fi

  echo "$field_txt"
  return 0
}

get_subject_from_ssl_cert_file() {
  local file="$1"

  get_field_from_ssl_cert_file subject "$file"
}

get_cn_from_ssl_cert_file() {
  local file="$1"

  local tmp_subj cn

  tmp_subj=$(get_subject_from_ssl_cert_file "$file") || return $?

  if cn=$(get_cn_from_asn_string "$tmp_subj"); then
    echo "$cn"
    return 0
  else
    return 1
  fi
}

get_cn_from_asn_string() {
  local asn="$1"
  
  if [ -z "$asn" ]; then
    echo "$FUNCNAME(): missing ASN string" 1>&2
    return 1
  fi

  local cn

  if [[ "$asn" == *CN=* ]]; then
    cn="${asn##*CN=}"
    cn="${cn#CN=}"
    cn="${cn%/*}"
    echo "$cn"
    return 0
  else
    echo "$FUNCNAME(): unable to parse CN information" 1>&2
    return 1
  fi
}

get_start_date_from_ssl_cert() {
  # echoes the start date of a SSL cert
  local file="$1"

  local tmp_start_str start_date

  tmp_start_str=$(get_field_from_ssl_cert_file startdate "$file") || \
    return $?

  start_date=${tmp_start_str#notBefore=}
  echo "$start_date"
  return 0
}

get_exp_date_from_ssl_cert() {
  # echoes the expiration date of a SSL cert
  local file="$1"

  local tmp_exp_str exp_date

  tmp_exp_str=$(get_field_from_ssl_cert_file enddate "$file") || return $?

  exp_date=${tmp_exp_str#notAfter=}
  echo "$exp_date"
  return 0
}

get_issuer_from_ssl_cert() {
  local file="$1"

  get_field_from_ssl_cert_file issuer "$file"
}

get_issuer_cn_from_ssl_cert() {
  local file="$1"

  local tmp_issuer_str issuer_cn

  tmp_issuer_str=$(get_issuer_from_ssl_cert "$file") || return $?

  issuer_cn=$(get_cn_from_asn_string "$tmp_issuer_str") || return $?

  echo "$issuer_cn"
}

get_key_value_from_vhost() {
  local key="$1"
  local vhost="${2:-$_dp_vhost}"

  local value
  unset _dp_value

  value=$(deref_contents \
            "$DEVPANEL_HOME/config/vhosts/$vhost/$key" 2>/dev/null) || return $?

	_dp_value="$value"

  [ -n "$_dp_print" ] && printf '%s' "$value"

  return 0
}

get_1st_level_field_value_from_app() {
  local vhost="$1"
  local field="$2"
  local prefix="app:0:_"
  local value

  value=$(get_vhost_key_value "$prefix:$field" "$vhost" 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo -n "$value"
    return 0
  else
    return 1
  fi
}

get_app_type_from_vhost() {
  local vhost="$1"

  if [ -n "$v__app__subsystem" ]; then
    echo "$v__app__subsystem"
    return 0
  else
    return 1
  fi
}

is_htpasswd_enabled_on_vhost() {
  local vhost="$1"
  local en

  if [ -n "$v__vhost__htpasswd" -a \
          "$v__vhost__htpasswd" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_fastcgi_enabled_on_vhost() {
  local vhost="$1"
  local key="apache_vhost:0:include:fastcgi"
  local en

  if [ -n "$v__vhost__fastcgi" -a \
          "$v__vhost__fastcgi" == yes ]; then
    return 0
  else
    return 1
  fi
}

get_mysql_db_name_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_name
}

get_mysql_db_host_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_host
}

get_mysql_db_port_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_port
}

get_mysql_db_host_port_from_vhost() {
  local vhost="$1"
  local db_host db_port

  db_host=$(get_mysql_db_host_from_vhost "$vhost" 2>/dev/null)
  db_port=$(get_mysql_db_port_from_vhost "$vhost" 2>/dev/null)

  if [ -n "$db_host" -a -n "$db_port" ]; then
    echo "$db_host:$db_port"
    return 0
  else
    return 1
  fi
}

get_mysql_db_user_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_user
}

get_mysql_db_password_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_password
}

can_do_fp_calcs() {
  # can do floiting point calculations?

  if hash bc &>/dev/null; then 
    # yes
    return 0
  else
    # no
    return 1
  fi
}

get_list_of_backup_files_from_vhost() {
  local basename_only

  while [ -n "$1" -a ${1:0:1} == - ]; do
    case "$1" in
      --basename)
        basename_only=1
        shift
        ;;
      *)
        echo "$FUNCNAME(): unknown option '$1'" 1>&2
        return 1
        ;;
    esac
  done

  local vhost="$1"

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local data_dir files_dir archive_file

  data_dir="$conf__paths__data_dir"

  files_dir=$(get_vhost_archives_dir "$vhost" )

  if [ ! -d "$files_dir" ]; then
    return 0
  fi

  local last_mod_e stat_output f_bname
  local size_bytes display_name

  for f_bname in $(ls -rt $files_dir); do
    archive_file="$files_dir/$f_bname"
    [ ! -f "$archive_file" ] && continue
    if [[ "$archive_file" != *.tgz ]]; then
      continue
    fi

    stat_output=$(stat --printf='%Y\t%s' "$archive_file")
    IFS=$'\t' read last_mod_e size_bytes <<< "$stat_output"

    if [ -n "$basename_only" ]; then
      display_name="${archive_file##*/}"
    else
      display_name="$archive_file"
    fi

    printf '%s\t%s\t%s\n' "$last_mod_e" "$size_bytes" "$display_name"
  done
}

get_list_of_backup_files_from_vhost_hr() {
  # return the list of backup files with human readable fields
  local -a args_ar=( "$@" )
  local line mtime size_bytes filename
  local fp
  local size_fmt mtime_fmt

  if can_do_fp_calcs; then
    fp=1
  fi

  # for line in $(get_list_of_backup_files_from_vhost "${args_ar[@]}"); do
  while read line; do
    IFS=$'\t' read mtime size_bytes filename <<< "$line"

    if [ -n "$fp" ]; then
      size_fmt=$(bytes_to_human "$size_bytes" )
    else
      size_fmt="$size_bytes bytes"
    fi

    mtime_fmt=$(date -d@$mtime +'%b %d %Y %H:%M UTC%:z')

    # mtime mtime_fmt size_bytes size_fmt $filename
    printf "%s\t%s\t%s\t%s\t%s\n" \
      "$mtime" "$mtime_fmt" "$size_bytes" "$size_fmt" "$filename"

  done < <(get_list_of_backup_files_from_vhost "${args_ar[@]}" )
}

get_list_of_backup_files_from_vhost_json() {
  local mtime mtime_fmt size_bytes size_fmt filename
  local line _info_json tmp_file st

  if ! tmp_file=$(mktemp); then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  local bkp_dir file_basename
  while read line; do
    IFS=$'\t' read mtime mtime_fmt size_bytes size_fmt filename <<< "$line"
    bkp_dir=${filename%/*}
    file_basename=${filename##*/}

    jo name="$file_basename" dir=$bkp_dir                  \
       size_bytes="$size_bytes" size_human="$size_fmt"     \
       mtime="$mtime" mtime_human="$mtime_fmt"             \
    >> "$tmp_file"

  done < <(get_list_of_backup_files_from_vhost_hr "$@" )

  jo -a < "$tmp_file"
  st=$?

  rm -f "$tmp_file"

  return $st
}

print_vhost_summary() {
  local vhost="$1"

  local summ_txt="
Information about vhost @vhost@

Status: @status_str@
Main URL: @main_url@

Domains: @domains@
SSL: @ssl_txt@
App: @app_type@
PHP Version: @php_version@
SFTP User: @ssh_user@
SFTP Host: @ssh_host@
MySQL Host/Port: @db_host_port@
MySQL Database:  @db_name@
FastCGI: @fastcgi_status@
Htpasswd: @htpasswd_status@
Snapshots: @snapshots_txt@
"

  if should_skip_nginx_vhost "$vhost"; then
    summ_txt+="Skipping nginx vhost: Yes"$'\n'
  fi

  local domains_txt="" out_txt="" status_str=""
  local main_url ssh_host ssh_user db_name db_host_port db_name app_type
  local fastcgi_status htpasswd_status
  local snapshots_txt
  local ssl_txt php_ver

  if is_vhost_enabled "$vhost"; then
    status_str=enabled
  else
    status_str=disabled
  fi

  main_url=$(get_main_url_of_vhost "$vhost")
  app_type=$v__app__subsystem
  db_host_port="$v__mysql__client__host:$v__mysql__client__port"
  db_name="$v__app__database_name"

  if is_fastcgi_enabled_on_vhost "$vhost"; then
    fastcgi_status=enabled
  else
    fastcgi_status=disabled
  fi
  
  if is_htpasswd_enabled_on_vhost "$vhost"; then
    htpasswd_status=enabled
  else
    htpasswd_status=disabled
  fi

  domains_txt+=$'\n'
  for domain in $v__vhost__domains; do
    domains_txt+="    $domain"$'\n'
  done

  ssh_user="$v__vhost__linux_user"

  local freq day hour retention day_var hour_var retention_var
  for freq in daily weekly monthly; do
    if are_snapshots_enabled_for_vhost "$vhost" $freq; then
      if [ -n "$snapshots_txt" ]; then
        snapshots_txt+=$'\n'
      else
        snapshots_txt+="enabled"$'\n'
      fi

      hour_var="v__recurring_snapshots_${freq}__hour"
      hour="${!hour_var}"
      retention_var="v__recurring_snapshots_${freq}__retention_unit"
      retention="${!retention_var}"

      snapshots_txt+="  $freq"
      if [ "$freq" != daily ]; then
        day_var="v__recurring_snapshots_${freq}__day"
        day="${!day_var}"
        snapshots_txt+=" on $day,"
      fi
      snapshots_txt+=" at hour $hour, retain $retention files"
    fi
  done
  
  if [ -z "$snapshots_txt" ]; then
    snapshots_txt="disabled"
  fi

  if is_ssl_enabled_on_vhost "$vhost"; then
    ssl_txt+="enabled"

    local ssl_cert_file ssl_cert_start_date ssl_cert_exp_date ssl_cert_cn
    local ssl_issuer_cn
    
    ssl_cert_file="$v__ssl__dir/cert.crt"
    ssl_txt+=$'\n'
    ssl_issuer_cn=$(get_issuer_cn_from_ssl_cert "$ssl_cert_file" \
                      2>/dev/null )
    [ $? -eq 0 ] && ssl_txt+="  Issuer: $ssl_issuer_cn"$'\n'

    ssl_cert_cn=$(get_cn_from_ssl_cert_file "$ssl_cert_file" 2>/dev/null )
    [ $? -eq 0 ] && ssl_txt+="  CN: $ssl_cert_cn"$'\n'

    ssl_cert_start_date=$(get_start_date_from_ssl_cert "$ssl_cert_file" \
                            2>/dev/null )
    [ $? -eq 0 ] && ssl_txt+="  Valid after: $ssl_cert_start_date"$'\n'

    ssl_cert_exp_date=$(get_exp_date_from_ssl_cert "$ssl_cert_file" \
                            2>/dev/null )
    [ $? -eq 0 ] && ssl_txt+="  Expires On:  $ssl_cert_exp_date"$'\n'

    ssl_txt+="  HTTP to HTTPS redirect: "
    if is_https_redirect_enabled_for_current_vhost; then
      ssl_txt+="yes"
      if [ -n "$v__ssl__https_redirect_target_domain" ]; then
        ssl_txt+=", targeted redirect to https://"
        ssl_txt+="$v__ssl__https_redirect_target_domain/"
      fi
      ssl_txt+=$'\n'
    else
      ssl_txt+="no"$'\n'
    fi
  else
    ssl_txt="disabled"
  fi

  if [ -n "$v__php__version" ]; then
    php_ver="$v__php__version"
  else
    php_ver="$lamp__php__default_version (system default)"
  fi

  if has_user_includes "$vhost"; then
    summ_txt+="Custom Includes: yes"$'\n'
  fi
 
  ssh_host=$lamp__apache_vhosts__virtwww_domain

  out_txt="$summ_txt"
  out_txt=${out_txt//@status_str@/$status_str}
  out_txt=${out_txt//@main_url@/$main_url}
  out_txt=${out_txt//@vhost@/$vhost}
  out_txt=${out_txt//@domains@/$domains_txt}
  out_txt=${out_txt//@ssl_txt@/$ssl_txt}
  out_txt=${out_txt//@app_type@/$app_type}
  out_txt=${out_txt//@php_version@/$php_ver}
  out_txt=${out_txt//@db_host_port@/$db_host_port}
  out_txt=${out_txt//@db_name@/$db_name}
  out_txt=${out_txt//@ssh_user@/$ssh_user}
  out_txt=${out_txt//@ssh_host@/$ssh_host}
  out_txt=${out_txt//@fastcgi_status@/$fastcgi_status}
  out_txt=${out_txt//@htpasswd_status@/$htpasswd_status}
  out_txt=${out_txt//@snapshots_txt@/$snapshots_txt}

  echo "$out_txt"
}

print_server_metadata_json() {
  local distro_updates_st distro_id distro_name_pretty distro_version
  local vhosts_base_domain
  local tmp_vhost tmp_vhost_json
  local tmp_dir_d tmp_vhosts_f tmp_vhosts_json_af
  local -a jo_args_ar
  local -a vhosts_ar
  local -i n_vhosts
  local -i st

  if is_distro_updates_enabled ; then
    distro_updates_st=1
  else
    distro_updates_st=0
  fi

  distro_id=$(devpanel_auto_detect_distro )
  distro_version=$(devpanel_auto_detect_distro_version "$distro_id")
  distro_name_pretty=$(get_linux_distro_name_pretty )

  vhosts_ar=( $(get_list_of_vhosts) )
  n_vhosts=${#vhosts_ar[*]}

  local tmp_dir_1

  if ! tmp_dir_1=$(mktemp -d); then
    echo "$FUNCNAME(): unable to create temp dir" 1>&2
    return 1
  fi

  tmp_vhosts_f="$tmp_dir_1/vhosts_1_obj_per_line.txt"
  tmp_vhosts_json_af="$tmp_dir_1/vhosts_ar.json"

  if [ $n_vhosts -eq 0 ]; then
    # save an empty array of vhosts
    echo -n '[]' > $tmp_vhosts_json_af
  else
    for((i=0; i < $n_vhosts; i++)); do
      tmp_vhost="${vhosts_ar[$i]}"
      load_vhost_config "$tmp_vhost" 2>/dev/null || continue
      print_vhost_metadata_json "$tmp_vhost"  >>$tmp_vhosts_f
    done

    # create a json formatted array of vhosts
    jo -a < $tmp_vhosts_f >$tmp_vhosts_json_af
  fi

  vhosts_base_domain=$lamp__apache_vhosts__virtwww_domain

  jo_args_ar+=(
    server.distro.id="$distro_id" server.distro.version="$distro_version"
    server.distro.title="$distro_name_pretty"
    server.distro.updates.enabled@$distro_updates_st
    server.vhosts_base_domain=$vhosts_base_domain
  )

  if [ -n "$conf__s3__bucket_name" ]; then
    jo_args_ar+=( server.s3.bucket_name=$conf__s3__bucket_name )

    local key var value
    for key in upload_by_default delete_after_upload; do
      var="conf__s3__$key"
      value="${!var}"
      if [ -n "$value" -a "$value" == yes ]; then
        jo_args_ar+=( server.s3.$key@1 )
      else
        jo_args_ar+=( server.s3.$key@0 )
      fi
    done

    local s3_file="$conf__s3__default_config_file"
    if [ -f "$s3_file" ]; then
      if read_ini_file_into_namespace "$s3_file" s3 2>/dev/null; then
        for key in region host_base host_bucket; do
          var="s3__default__${key}"
          value="${!var}"
          if [ -n "$value" ]; then
            jo_args_ar+=( server.s3.$key=$value )
          fi
        done
      fi
    fi
  fi
      
  jo -p -d . devpanel.metadata.version=1 \
    vhosts:=$tmp_vhosts_json_af "${jo_args_ar[@]}"

  st=$?

  rm -rf "$tmp_dir_1"
  
  return $st
}

print_vhost_metadata_json() {
  if [ $# -eq 0 ]; then
    echo "$FUNCNAME(): missing arguments" 1>&2
    return 1
  fi

  local opt_name pretty
  while [ -n "$1" -a "${1:0:1}" == - ]; do
    opt_name="$1"

    case $opt_name in
      --pretty)
        pretty=1
        shift
        ;;
      *)
        echo "$FUNCNAME(): unknown option $opt_name" 1>&2
        return 1
        ;;
    esac
  done

  local vhost="$1"

  if ! vhost_exists "$vhost"; then 
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local tmp_dir_1
  if ! tmp_dir_1=$(mktemp -d); then
    echo "$FUNCNAME(): unable to create temp dir" 1>&2
    return 1
  fi

  local tmp_domains_f="$tmp_dir_1/domains_1_per_line.txt"
  local tmp_domains_json_af="$tmp_dir_1/domains_ar.json"
  local tmp_bkp_files_json_ar="$tmp_dir_1/bkp_files_ar.json"

  local vhost_st fastcgi_st htpasswd_st st
  local -a ssl_opts_ar
  local app_type db_name doc_root user_inc_st https_redir_st
  local mysql_host mysql_user mysql_port mysql_password
  local linux_user
  local ssl_st ssl_type
  local php_version stack

  echo "${v__vhost__domains// /$'\n'}" >$tmp_domains_f
  jo -a < $tmp_domains_f >$tmp_domains_json_af

  get_list_of_backup_files_from_vhost_json "$vhost" >$tmp_bkp_files_json_ar

  doc_root="$v__vhost__document_root"

  if is_vhost_enabled "$vhost"; then
    vhost_st=1
  else
    vhost_st=0
  fi

  app_type=$v__app__subsystem
  db_name=$v__app__database_name
  mysql_host=$v__mysql__client__host
  mysql_port=$v__mysql__client__port
  mysql_user=$v__mysql__client__user

  linux_user=$v__vhost__linux_user

  if is_fastcgi_enabled_on_vhost "$vhost"; then
    fastcgi_st=1
  else
    fastcgi_st=0
  fi

  if is_htpasswd_enabled_on_vhost "$vhost"; then
    htpasswd_st=1
  else
    htpasswd_st=0
  fi

  if is_ssl_enabled_on_vhost "$vhost"; then
    ssl_st=1
    if is_lets_encrypt_enabled_for_vhost "$vhost"; then
      ssl_type="lets-encrypt"
    else
      ssl_type="manual"
    fi
    ssl_opts_ar+=( "ssl.type=$ssl_type" )

    if is_https_redirect_enabled_for_current_vhost; then
      https_redir_st=1
    else
      https_redir_st=0
    fi
    ssl_opts_ar+=( "ssl.https_redirect@$https_redir_st" )
  else
    ssl_st=0
  fi
  ssl_opts_ar+=( "ssl.enabled@$ssl_st" )

  if [ -n "$v__php__version" ]; then
    # specific PHP version for this vhost
    php_version="$v__php__version"
    stack="$php_version"
  else
    # use server wide PHP version
    php_version="$lamp__php__default_version"
    stack="$php_version"
  fi

  if has_user_includes "$vhost"; then
    user_inc_st=1
  else
    user_inc_st=0
  fi

  jo ${pretty:+-p} -d . name=$vhost enabled@$vhost_st stack=$stack \
    domains:=$tmp_domains_json_af document_root="$doc_root" \
    backup_files:=$tmp_bkp_files_json_ar user_includes@$user_inc_st \
    fastcgi.enabled@$fastcgi_st htpasswd.enabled@$htpasswd_st \
    app.linux_user="$linux_user" app.type=$app_type app.database_name=$db_name \
    app.mysql_host=$mysql_host app.mysql_port=$mysql_port \
    app.mysql_user=$mysql_user \
    "${ssl_opts_ar[@]}"
  st=$?

  rm -rf "$tmp_dir_1"

  return $st
}

is_https_redirect_enabled_by_default() {
  local var="lamp__apache_ssl__redirect_http_to_https_by_default"

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_https_redirect_enabled_for_current_vhost() {
  local var="v__ssl__https_redirect"

  if [ -n "${!var}" -a "${!var}" == yes ]; then
    return 0
  elif [ -n "${!var}" -a "${!var}" != yes ]; then
    return 1
  elif is_https_redirect_enabled_by_default ; then
    return 0
  else
    return 1
  fi
}

get_vhost_include_filename() {
  local vhost="$1"

  local file_base
  local config_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  file_base=$(get_user_include_metadata "$vhost" user_includes)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get user include base name" 1>&2
    return 1
  fi

  local config_file="$config_dir/$file_base.inc"

  echo "$config_file"
}

has_user_includes() {
  local vhost="$1"

  get_user_include_metadata "$vhost" user_includes &>/dev/null
}

ltsv_get_value() {
  local key="$1"
  local line="${2:-$_ltsv_line}"

  unset _ltsv_value

  local value tmp_ext_1 tmp_ext_2

  if ! [[ "$line" == *$key:* ]]; then
    return 1
  fi

  tmp_ext_1=${line#$key:}
  if [ "$tmp_ext_1" != "$line" ]; then
    # parameter is the first one on the line
    # remove any remaining text
    value=${tmp_ext_1%%$'\t'*}
  else
    # check beyond the first position
    tmp_ext_2=${line##*$'\t'$key:}
    if [ "$tmp_ext_2" == "$line" ]; then
      return 1 # parameter not found
    else
      # remove any remaining text
      value=${tmp_ext_2%%$'\t'*}
    fi
  fi

  _ltsv_value="$value"

  [ -n "$_ltsv_print" ] && printf '%s' "$value"

  return 0
}

ltsv_has_key_with_value() {
  local key="$1"
  local wanted_value="$2"
  local line="${3:-$_ltsv_line}"
  local found_value=""

  ltsv_get_value "$key" "$line" || return 1

  found_value="$_ltsv_value"
  if [ "$found_value" == "$wanted_value" ]; then
    return 0
  else
    return 1
  fi
}

ltsv_find_line_with_keys_n_values() {
	local file="$1"
  shift

  local -a keys_ar values_ar
  local key value line
  while [ -n "$1" ]; do
    key=${1%%=*}
    value=${1#*=}

    keys_ar+=( "$key" )
    values_ar+=( "$value" )
    shift
  done

  local -i n_keys=${#keys_ar[@]}
  while read line; do
    [ -z "$line"           ] && continue
    [ "${line:0:1}" == "#" ] && continue

    _ltsv_line="$line"

    local -i max_n=$(( $n_keys - 1 ))
    for((i=0; i <= $max_n; i++)); do
      key=${keys_ar[$i]}
      value=${values_ar[$i]}

      if ltsv_has_key_with_value "$key" "$value"; then
        if [ $i == $max_n ]; then
          # test all key-values, and all matched
          echo "$line"
          return 0
        fi
      else
        break
      fi
    done
  done < "$file"

  unset _ltsv_line
  return 1
}

get_default_app_publisher() {
  if [ -n "$conf__publishers__default" ]; then
    echo "$conf__publishers__default"
    return 0
  else
    return 1
  fi
}

is_known_seedapp_publisher() {
  local pub="$1"

  get_base_url_for_publisher "$pub" >/dev/null
}

get_base_url_for_publisher() {
  local publisher="$1"

  local var="conf__publisher_${publisher}__base_url"

  if [ -n "${!var}" ]; then
    echo "${!var}"
    return 0
  else
    return 1
  fi
}

get_app_metadata_from_publisher() {
  local publisher="$1"
  local tmp_file="$2"

  local base_url metadata_url
  local created_tmp

  base_url=$(get_base_url_for_publisher "$publisher") || return $?
  metadata_url="${base_url%/}/metadata.ltsv"

  if [ -z "$tmp_file" ]; then
    tmp_file=$(mktemp)
    if [ $? -eq 0 ]; then
      created_tmp=1
    else
      echo "$FUNCNAME(): unable to create temporary file" 1>&2
      return 1
    fi
  fi

  download_file "$metadata_url" "$tmp_file"
  local st=$?
  if [ $st -eq 0 ]; then
    if [ -n "$created_tmp" ]; then
      cat "$tmp_file"
      rm -f "$tmp_file"
    fi
  else
    rm -f "$tmp_file"
    echo "$FUNCNAME(): unable to get app metadata from $publisher" 1>&2
  fi

  return $st
}

get_app_info_from_publisher() {
  local app="$1"
  local publisher="$2"
  local tmp_file

  tmp_file=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  if ! get_app_metadata_from_publisher "$publisher" "$tmp_file"; then
    rm -f "$tmp_file"
    return 1
  fi

  local info_txt
  info_txt=$(ltsv_find_line_with_keys_n_values "$tmp_file" name="$app")
  local st=$?

  if [ $st -eq 0 ]; then
    echo "$info_txt"
  fi

  rm -f "$tmp_file"

  return $st
}

get_tarball_url_for_app() {
  local app="$1"
  local publisher="$2"

  local -a info_ar=()
  local old_IFS="$IFS"
  IFS=$'\n' info_ar=( $( get_app_info_from_publisher "$app" "$publisher") )
  local st=$?
  IFS="$old_IFS"

  if [ $st -ne 0 ]; then
    echo "$FUNCNAME(): no such app '$app' on $publisher" 1>&2
    return $st
  elif [ -z "${info_ar[*]}" ]; then
    echo "$FUNCNAME(): no such app '$app' on $publisher" 1>&2
    return 1
  elif [ ${#info_ar[@]} -gt 1 ]; then
    echo "$FUNCNAME(): got more than one record for app '$app' on '$publisher'" 1>&2
    return 1
  fi
  
  local file_uri base_url real_url
  if ltsv_get_value file_uri "${info_ar[0]}"; then
    file_uri="$_ltsv_value"
  else
    echo "$FUNCNAME(): missing file_uri field for app $app" 1>&2
    return 1
  fi

  if ! ltsv_get_value enabled "${info_ar[0]}" ||
       [ "$_ltsv_value" != "true" ]; then

    echo "$FUNCNAME(): app '$app' is not enabled for installs" 1>&2
    return 1
  fi

  base_url=$(get_base_url_for_publisher "$publisher") || return $?
  real_url="${base_url%/}/${file_uri#/}"

  echo "$real_url"

  return 0
}

set_vhost_description() {
  local desc="$1"
  local vhost="$2"

  save_opts_in_vhost_config "$vhost" "vhost.description = $desc"
}

remove_vhost_description() {
  local vhost="$1"

  save_opts_in_vhost_config "$vhost" "- vhost.description"
}

get_vhost_description() {
  local vhost="$1"

  if [ -n "$v__vhost__description" ]; then
    echo "$v__vhost__description"
    return 0
  else
    return 1
  fi
}

get_apache_ports_file() {
  local var
  var=lamp__apache_paths__ports_file
  if [ -n "${!var}" ]; then
    echo "${!var}"
    return 0
  else
    return 1
  fi
}

install_distro_pkgs() {
  local distro="$1"
  local distro_major_ver="$2"
  local pkg_list_file="$3"

  if [ $# -ne 3 -o -z "$1" -o -z "$2" -o -z "$3" ]; then
    echo "$FUNCNAME(): required args -" \
           "distro, distro_major_version, pkg_list_file" 1>&2
    return 1
  fi

  if [ ! -f "$pkg_list_file" ]; then
    echo "$FUNCNAME(): missing file '$pkg_list_file'" 1>&2
    return 1
  elif [ ! -s "$pkg_list_file" ]; then
    echo "$FUNCNAME(): list file '$pkg_list_file' is empty" 1>&2
    return 1
  fi

  local -a cmd_ar=()
  case "$distro" in
    centos|redhat)
      cmd_ar=( yum -y install )
      ;;
    debian|ubuntu)
      cmd_ar=( apt-get -y install )
      ;;
    *)
      echo "$FUNCNAME(): don't know how to install packages for distro" \
        "$distro" 1>&2
      return 1
      ;;
  esac

  local pkg_regex='^[[:space:]]*[^[:space:]#]+'

  if egrep -q "$pkg_regex" "$pkg_list_file"; then
    egrep "$pkg_regex" "$pkg_list_file" | xargs -n 100 "${cmd_ar[@]}"
  else
    echo "$FUNCNAME(): didn't find any package in the list" 1>&2
    return 1
  fi
}

get_php_version_from_vhost() {
  local vhost="$1"

  if [ -n "$v__php__version" ]; then
    echo "$v__php__version"
    return 0
  else
    return 1
  fi
}

set_system_default_php_version() {
  local version="$1"

  save_opts_in_lamp_config "php.default_version = $version"
}

get_default_php_version() {
  local var="lamp__php__default_version"
  if [ -n "${!var}" ]; then
    echo "${!var}"
    return 0
  else
    return 1
  fi
}

get_path_of_php_bin_by_version() {
  local file="$1"
  local version="$2"
  local var value

  local file_mod=${file//-/_}
  local ver_mod=${version//./_}

  var="lamp__php_paths__${file_mod}_${ver_mod}"
  if [ -n "${!var}" ]; then
    value="${!var}"
  fi

  if [ -n "$value" ]; then
    echo "$value"
  else
    echo "$FUNCNAME(): couldn't find value for '$file' version '$version'" 1>&2
    return 1
  fi
}

get_path_of_php_lnk_dir() {
  local var value

  var="lamp__php_paths__php_lnk_dir"
  if [ -n "${!var}" ]; then
    value="${!var}"
  fi

  if [ -n "$value" ]; then
    echo "$value"
    return 0
  else
    echo "$FUNCNAME(): can't find php_lnk_dir" 1>&2
    return 1
  fi
}

get_ssl_cert_dir() {
  if [ -n "$v__ssl__dir" ]; then
    echo "$v__ssl__dir"
    return 0
  else
    return 1
  fi
}

get_ssl_key_dir() {
  if [ -n "$v__ssl__dir" ]; then
    echo "$v__ssl__dir"
    return 0
  else
    return 1
  fi
}

is_nginx_on_port80() {
  local apache_port pids_on_port80 tst_pid pid_exe

  apache_port=$(get_apache_http_port ) || return $?

  if [ "$apache_port" != 80 ]; then
    if pids_on_port80=$(fuser 80/tcp 2>/dev/null ); then
      while [ -n "$pids_on_port80" -a "${pids_on_port80:0:1}" == " " ]; do
        # remove the leading space from the output
        pids_on_port80="${pids_on_port80# }"
      done

      # test the first pid to see if it's nginx
      tst_pid=${pids_on_port80%% *}

      pid_exe=$(readlink -e /proc/$tst_pid/exe ) || return $?
      if [[ "$pid_exe" == *nginx ]]; then
        return 0
      fi
    fi
  fi

  return 1
}

write_nginx_local_vhost() {
  local vhost="$1"

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local nginx_vhost_dir nginx_vhost_lnk_dir
  local vhost_base_domain vhost_file vhost_lnk vhost_hostnames vhost_txt
  local apache_http_port server_base_domain

  server_base_domain=$(get_server_base_domain )       || return $?
  vhost_base_domain=$(get_vhost_base_domain "$vhost") || return $?
  apache_http_port=$(get_apache_http_port )           || return $?

  nginx_vhost_dir="/etc/nginx/sites-available"
  if [ ! -d "$nginx_vhost_dir" ]
  then
      mkdir -p $nginx_vhost_dir
  fi
  nginx_vhost_lnk_dir="/etc/nginx/sites-enabled"

  vhost_file="$nginx_vhost_dir/$vhost_base_domain.conf"
  vhost_lnk="$nginx_vhost_lnk_dir/$vhost_base_domain.conf"

  local vhost_tmpl_txt='
server {
  listen       80;
  server_name  @vhost_hostnames@ @vhost@-gen.@server_base_domain@;
  location / {
    proxy_set_header Host $host;
    proxy_pass http://127.0.0.1:@apache_http_port@;
  }
}
'

  vhost_hostnames=$(get_hostnames_from_vhost "$vhost") || return $?
  vhost_hostnames=${vhost_hostnames//$'\n'/ }
  vhost_txt="$vhost_tmpl_txt"
  vhost_txt="${vhost_txt//@vhost@/$vhost}"
  vhost_txt="${vhost_txt//@server_base_domain@/$server_base_domain}"
  vhost_txt="${vhost_txt//@vhost_hostnames@/$vhost_hostnames}"
  vhost_txt="${vhost_txt//@apache_http_port@/$apache_http_port}"

  if echo "$vhost_txt" >"$vhost_file"; then
    rm -f "$vhost_lnk"
    ln -s "$vhost_file" "$vhost_lnk"
  else
    echo "$FUNCNAME(): unable to write vhost file '$vhost_file'" 1>&2
    return 1
  fi
}

should_skip_nginx_vhost() {
  local vhost="$1"

  if get_vhost_key_value skip_nginx_vhost "$vhost" &>/dev/null; then
    # key present, skip it
    return 0
  else
    # key not present, don't skip it (write it)
    return 1
  fi
}

extract_vhost_files_from_dir() {
  local src_dir="$1"
  local target_vhost="$2"
  local vhost_home="$3"
  local doc_root="$4"

  local old_vhost old_doc_root old_vhost_file
  local test_file_1 test_file_2 archive_file
  local -a tar_args_ar=()

  old_vhost_file="$src_dir/id"
  
  if ! old_vhost=`head -1 "$old_vhost_file"` || [ -z "$old_vhost" ]; then
    echo "$FUNCNAME(): cannot read $old_vhost_file" >&2
    return 1
  fi 
  old_doc_root="./public_html/$old_vhost"
 
  test_file_1="$src_dir/w_$old_vhost.tgz" 
  test_file_2="$src_dir/$old_vhost.tgz" 
  if [ -f "$test_file_1" ]; then 
    # backwards compatibility when only short vhost names were allowed 
    archive_file="$test_file_1" 
  elif [ -f "$test_file_2" ]; then 
    archive_file="$test_file_2" 
  else 
    echo "$FUNCNAME(): unable to find an archive file to restore" 1>&2
    return 1
  fi 

  tar_args_ar+=( --no-same-owner --exclude=.mysql.passwd \
                 --exclude=./.my.cnf --exclude=./logs )

  if [ "$old_vhost" != "$target_vhost" ]; then
    tar_args_ar+=( --exclude="$old_doc_root" )

    # now extract only the doc_root
    if ! tar -zSxf "$archive_file" -C "$doc_root" --no-same-owner \
      --strip-components 3 "$old_doc_root" ; then
      echo "$FUNCNAME(): failed to extract doc_root '$old_doc_root'" \
           "from '$archive_file'" 1>&2
      return 1
    fi
  fi

  if tar -zxSf "$archive_file" -C "$vhost_home" "${tar_args_ar[@]}"; then
    return 0
  else
    echo "$FUNCNAME(): failed to extract files from '$archive_file'" 1>&2
    return 1
  fi
}

mysql_write_my_cnf() {
  local vhost="$1"
  local user="$2"
  local dir="$3"

  local host port user password
  local contents
  local -a cmd_ar=( 
    "$DEVPANEL_HOME/bin/update-ini-file" -q -c "$dir/.my.cnf"
  )

  host=$(get_1st_level_field_value_from_app "$vhost" db_host )
  port=$(get_1st_level_field_value_from_app "$vhost" db_port )
  user=$(get_1st_level_field_value_from_app "$vhost" db_user )
  password=$(get_1st_level_field_value_from_app "$vhost" db_password )

  contents=$( \
    printf 'client.host = %s\nclient.port = %s\nclient.user = %s\n' \
        "$host" "$port" "$user" ;
     printf 'client.password = %s\n' "$password"; \
  )
    
  if [ $EUID -eq 0 ]; then
    echo "$contents" | run_as_user "$user" "${cmd_ar[@]}"
  else
    echo "$contents" | "${cmd_ar[@]}"
  fi
}

is_apache_running() {
  local port

  port=$(get_apache_http_port ) || return $?

  fuser -s $port/tcp 2>/dev/null
}

start_apache() {
  local svc_name

  svc_name=$(get_apache_service_name 2>/dev/null) || return $?

  service $svc_name start
}

stop_apache() {
  local svc_name

  svc_name=$(get_apache_service_name 2>/dev/null) || return $?

  service $svc_name stop
}

restart_apache() {
  if is_apache_running; then
    stop_apache
  fi

  start_apache
}

reload_apache() {
  local svc_name

  svc_name=$(get_apache_service_name 2>/dev/null) || return $?

  service $svc_name reload
}

apache_configtest() {
  local svc_name
  local apachectl_bin

  svc_name=$(get_apache_service_name 2>/dev/null) || return $?

  if [ "$svc_name" == apache2 ]; then
    apachectl_bin=apache2ctl
  else
    apachectl_bin=apachectl
  fi

  $apachectl_bin configtest
}

reload_or_start_apache() {
  if is_apache_running; then
    reload_apache
  else
    start_apache
  fi
}

rewrite_vhost_apache_config() {
  local vhost="$1"

  "$DEVPANEL_HOME/libexec/rewrite-vhost-config" "$vhost"
}

get_system_lock_dir() {
  local lock_dir_1="/run/devpanel/lock"
  local lock_dir_2="/var/run/devpanel/lock"
  local lock_dir

  if [ -d "$lock_dir_1" ]; then
    lock_dir="$lock_dir_1"
  elif [ -d "$lock_dir_2" ]; then
    lock_dir="$lock_dir_2"
  else
    echo "$FUNCNAME(): no lock dir found" 1>&2
    return 1
  fi

  echo "$lock_dir"
  return 0
}

reserve_port() {
  local proto="$1"
  local port="$2"

  local tmp_clobber rsv_file
  local -i st

  if [[ "$-" != *C* ]]; then
    # file clobber (no overwriting) is disabled, temporary enable it
    set -C
    tmp_clobber=yes
  fi

  rsv_file="$conf__paths__port_reservation_dir/$proto.$port"

  : 2>/dev/null >"$rsv_file"
  st=$?

  if [ -n "$tmp_clobber" ]; then
    # disable file clobbering again
    set +C
  fi

  return $st
}

assign_available_port() {
  local proto="${1,,}"
  local ref_port_state="state__ports_${proto}__last_assigned"
  local -i first_port last_port n_ports n_trials

  unset _dp_value

  if [ -n "$conf__ports__last_port" ]; then
    last_port=$conf__ports__last_port
  else
    echo "$FUNCNAME(): error, missing variable conf__ports__last_port" 1>&2
    return 1
  fi

  if [ -n "${!ref_port_state}" ]; then
    # the last port used is in the state cache
    if [ "${!ref_port_state}" -ge $conf__ports__first_port -a \
         "${!ref_port_state}" -le $conf__ports__last_port       ]; then
      # port saved in state cache is in the valid range

      first_port=$(( ${!ref_port_state} + 1 ))
      if [ $first_port -gt $last_port ]; then
        first_port=$conf__ports__first_port
      fi
    else
     # port saved in state is outside the conf range. So ignore it
     first_port=$conf__ports__first_port
    fi
  else
    # last port used is not cached. So use the first one in the range.
    if [ -n "$conf__ports__first_port" ]; then
      first_port=$conf__ports__first_port
    else
      echo "$FUNCNAME(): error, missing variable conf__ports__first_port" 1>&2
      return 1
    fi
  fi

  n_ports=$(( $conf__ports__last_port - $conf__ports__first_port + 1 ))

  for((i=$first_port; i <= $last_port; i++)); do
    n_trials+=1
    if reserve_port "$proto" $i; then
      _dp_value="$i"
      save_opts_in_state "ports_${proto}.last_assigned = $i"
      return 0
    else
      if [ $i == $last_port -a $n_trials -le $n_ports ]; then
        # if it's the last port and it hasn't tried all ports yet, then
        # reset the trial value to the config's first port
        i=$(( $conf__ports__first_port - 1 ))
        continue
      fi

      if [ $n_trials -ge $n_ports ]; then
        # tried all the ports, give up the loop
        break
      fi
    fi
  done

  return 1
}

release_port() {
  local proto="${1,,}"
  local port="$2"
  local port_file="$conf__paths__port_reservation_dir/$proto.$port"

  if [ ! -e "$port_file" ]; then
    echo "$FUNCNAME(): warning, port not assigned" 1>&2
    return 0
  fi

  rm -f "$port_file"
}

force_kill_proc_using_file() {
  local file="$1"
  local -i i

  if ! fuser -s "$file" 2>/dev/null; then
    echo "$FUNCNAME(): no process using file $file" 1>&2
    return 1
  fi

  if ! fuser -s -k -TERM "$file" 2>/dev/null; then
    echo "$FUNCNAME(): unable to send TERM signal to process using file $file" 1>&2
    return 1
  fi

  for i in {1..20}; do
    sleep 0.2
    if ! fuser -s "$file" 2>/dev/null; then
      # process is not running anymore
      return 0
    fi
  done

  # finally send a KILL signal if the process didn't exit after previous
  # time
  fuser -s -k -KILL "$file" 2>/dev/null
}

dmi_id_matches() {
  local id="$1"
  local search_string="$2"
  local id_file="/sys/devices/virtual/dmi/id/$id"
  local ver_string

  if [ -f "$id_file" ]; then
    IFS='' read ver_string < "$id_file"
    if [ -n "$ver_string" ] && [[ "${ver_string,,}" == *$search_string* ]]; then
      return 0
    fi
  fi

  return 1
}

bios_version_matches() {
  local search_string="$1"
  dmi_id_matches bios_version "$search_string"
}

bios_vendor_matches() {
  local search_string="$1"
  dmi_id_matches bios_vendor "$search_string"
}

am_i_on_aws() {
  if bios_version_matches amazon; then
    return 0
  fi

  local output
  local url='http://169.254.169.254/latest/meta-data/public-hostname'

  output=$(curl -sSN --max-time 3 --connect-timeout 2 --retry 1 \
            --retry-delay 1 "$url" )
  if [ $? -eq 0 ] && [[ "$output" == *.amazonaws.com ]]; then
    return 0
  else
    return 1
  fi
}

am_i_on_virtualbox() {
  bios_version_matches virtualbox
}

am_i_on_digital_ocean() {
  bios_vendor_matches digitalocean
}

for _name in base lamp_vhost linux-kernel mysql; do
  if [ -f "$DEVPANEL_HOME/lib/functions.$_name.sh" ]; then
    . "$DEVPANEL_HOME/lib/functions.$_name.sh"
  else
    :
  fi
done
