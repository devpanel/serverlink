#!/bin/bash
if [ -z "$DEVPANEL_HOME" ]; then
  tmp_self=$(readlink -e "${BASH_SOURCE[0]}")
  if [ $? -eq 0 ]; then
    tmp_self_dir="${tmp_self%/*}"
    DEVPANEL_HOME=$(readlink -e "$tmp_self_dir/..")
  fi
  unset tmp_self tmp_self_dir
fi

# avoid a warning on MacOS X because md5sum doesn't exist
if [ -n "$OSTYPE" ] && [[ "$OSTYPE" =~ ^darwin ]] && hash md5 &>/dev/null; then
  hash -p $(which md5) md5sum
fi

error() {
  local msg="$1"
  local exit_code="${2:-1}"

  [ -n "$msg" ] && echo "Error: $msg" 1>&2

  if [ "$exit_code" == - ]; then
    return 1
  else
    exit $exit_code
  fi
}

wedp_warn() {
  local msg="$1"

  echo "Warning: $msg" 1>&2
}

devpanel_auto_detect_distro() {
  local distro=""

  # can't use local -l below because of systems with bash 3
  local lsb_distro_str="" lsb_distro_raw=""

  if hash lsb_release &>/dev/null; then
    lsb_distro_raw=`lsb_release -si 2>/dev/null`
    lsb_distro_str=`echo -n "$lsb_distro_raw" | tr A-Z a-z`
  fi

  if [ -n "$lsb_distro_str" ]; then
    distro="$lsb_distro_str"
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+debian\.org>'; then
    distro=debian
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+ubuntu\.com>'; then
    distro=ubuntu
  elif hash rpm &>/dev/null && rpm -ql centos-release &>/dev/null; then
    distro=centos
  elif hash rpm &>/dev/null && rpm -ql redhat-release-server &>/dev/null; then
    distro=redhat
  elif hash rpm &>/dev/null && rpm -ql owl-hier >/dev/null 2>&1; then
    distro=owl
  elif [[ "$OSTYPE" =~ ^darwin ]]; then
    distro=macosx
  fi

  if [ -n "$distro" ]; then
    echo "$distro"
    return 0
  else
    return 1
  fi
}

wedp_auto_detect_distro() {
  local distro=""

  # can't use local -l below because of systems with bash 3
  local lsb_distro_str="" lsb_distro_raw=""

  if hash lsb_release &>/dev/null; then
    lsb_distro_raw=`lsb_release -si 2>/dev/null`
    lsb_distro_str=`echo -n "$lsb_distro_raw" | tr A-Z a-z`
  fi

  if [ -n "$lsb_distro_str" ]; then
    distro="$lsb_distro_str"
  elif grep -qis centos /etc/redhat-release; then
    distro=centos
  elif grep -qis "Red Hat Enterprise Linux" /etc/redhat-release; then
    distro=redhat
  elif grep -qis fedora /etc/redhat-release; then
    distro=fedora
  elif rpm -ql owl-hier >/dev/null 2>&1; then
    distro=owl
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+debian\.org>'; then
    distro=debian
  elif [ -r /etc/debian_version ] && apt-cache show lsb-base | egrep -q '^Maintainer: .+ubuntu\.com>'; then
    distro=ubuntu
  elif [ -r /etc/gentoo-release ]; then
    distro=gentoo
  elif [[ "$OSTYPE" =~ ^darwin ]]; then
    distro=macosx
  fi

  if [ -n "$distro" ]; then
    echo "$distro"
    return 0
  else
    return 1
  fi
}

wedp_auto_detect_distro_version() {
  local distro="$1"
  local version_str="" version_number=""

  if [ -z "$distro" ]; then
    distro=$(wedp_auto_detect_distro) || return $?
  fi

  if hash lsb_release &>/dev/null; then
    version_number=`lsb_release -sr`
    [ $? -ne 0 ] && return 1
  elif [ "$distro" == "centos" ]; then
      version_str=$(head -1 "/etc/redhat-release" 2>/dev/null)
      [ $? -ne 0 ] && return 1

      # the line below is an invalid syntax on older systems with bash 3
      #if [[ "$version_str" =~ CentOS\ release\ ([0-9]+\.[0-9]+) ]]; then
      # so we have to pipe fgrep and egrep to have a compatible way on all
      # systems
      version_number=`echo "$version_str" | egrep -i 'centos .*release' | \
                        egrep -o '[0-9]+\.[0-9]+(\.[0-9]+)?' 2>/dev/null`
  fi

  if [ -n "$version_number" ]; then
    echo -n "$version_number"
    return 0
  else
    echo "$FUNCNAME(): unable to detect distro version" 1>&2
    return 1
  fi
}

get_linux_distro_string() {
  local os_release_file=/etc/os-release
  local tmp_1 tmp_2
  local distro_str

  if hash lsb_release &>/dev/null; then
    distro_str=$(lsb_release -sd)
  elif [ -f "$os_release_file" ]; then
    tmp_1=$(egrep -x -m 1 'PRETTY_NAME="[^"]+"' /etc/os-release)
    if [ $? -ne 0 -o -z "$tmp_1" ]; then
      echo "$FUNCNAME(): unable to get string from $os_release_file" 1>&2
      return 1
    fi

    tmp_2=${tmp_1#PRETTY_NAME=\"}
    distro_str=${tmp_2%\"}
    return 0
  else
    echo "$FUNCNAME(): don't know how to get info about linux distro" 1>&2
    return 1
  fi

  echo "$distro_str"
}

get_apache_ssl_template_name() {
  local ssl_dir ssl_tmpl
  ssl_tmpl=$(deref_os_prop "$DEVPANEL_HOME" names/apache_vhost_ssl_template )
  if [ $? -eq 0 ]; then
    echo "$ssl_tmpl"
    return 0
  else
    echo "$FUNCNAME(): unable to get the name of the SSL template" 1>&2
    return 1
  fi
}

get_apache_http_port() {
  local apache_config_dir="$DEVPANEL_HOME/config/packages/apache_vhost"
  get_metadata_value "$apache_config_dir" _:Port
}

get_apache_https_port() {
  local ssl_tmpl ssl_dir
  ssl_tmpl=$(get_apache_ssl_template_name) || return $?
  ssl_dir="$DEVPANEL_HOME/config/packages/apache_vhost/templates/$ssl_tmpl"

  get_metadata_value "$ssl_dir" _:Port
}

set_apache_http_port() {
  local port="$1"
  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  elif [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): received a malformed port" 1>&2
    return 1
  fi

  echo "set-local _:Port $port" | "$DEVPANEL_HOME/bin/metadata-handler" -q \
                                    "$DEVPANEL_HOME/config/packages/apache_vhost"
}

set_apache_https_port() {
  local port="$1"
  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  elif [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): received a malformed port" 1>&2
    return 1
  fi

  local ssl_dir ssl_tmpl
  ssl_tmpl=$(get_apache_ssl_template_name) || return $?
  ssl_dir="$DEVPANEL_HOME/config/packages/apache_vhost/templates/$ssl_tmpl"

  echo "set-local _:Port $port" | "$DEVPANEL_HOME/bin/metadata-handler" -q \
                                    "$ssl_dir"
}

print_quoted_variables() {
  local line=""
  local var=""

  for var in "$@"; do
    line=$(declare -p $var)
    line=${line#declare -x}
    echo $line
  done
}

escape_sed() {
  local str="$1"
  local escaped="$str"

  escaped=${escaped//\'/\\\'}
  escaped=${escaped//\*/\\*}
  escaped=${escaped//\;/\\;}
  escaped=${escaped//\[/\\[}
  escaped=${escaped//\]/\\]}
  escaped=${escaped//\\+/+\]}
  escaped=${escaped//\\\?/\?}
  escaped=${escaped//\\\(/\(}
  escaped=${escaped//\\\)/\)}
  escaped=${escaped//\//\\/}
  escaped=${escaped//\&/\\\&}
  escaped=${escaped//$'\n'/\\n}

  echo -n "$escaped"
}

in_array() {
  local value="$1"
  shift

  local v

  [ -z "$*" ] && return 1 # empty list

  for v in "$@"; do
    if [ "$v" == "$value" ]; then
      return 0
    fi
  done

  return 1
}

# the function below is a candidate to be removed as it's much better to use
# variable ${BASH_SOURCE[0]}, though not removing it now because not sure if
# it's being used by other scripts
resolve_local_dir() {
  local base="$1"
  local bin=""
  local bin_path=""
  local dir_name=""

  [ ${#base} -eq 0 ] && return 1

  if [ ${base:0:1} == "/" ]; then
    echo $(dirname "$base")
    return 0
  elif [ ${#base} -gt 2 -a ${base:0:2} == "./" ]; then
    base=${base#./}
    dir_name=$(dirname "$base")
    if [ "$dir_name" == "." ]; then
      echo "$PWD"
    else
      echo "$PWD/$dir_name"
    fi 
    return 0
  elif [ ${#base} -gt 2 -a ${base:0:3} == "../" ]; then
    echo $(dirname "$PWD/$base")
  else
    return 1
  fi 
}

wedp_resolve_link() {
  local source="$1"
  local target=""

  [ -z "$source" ] && return 1

  target=$(readlink -m "$source")
  if [ $? -eq 0 ]; then
    echo "$target"
    return 0
  else
    return 1
  fi
}

wedp_gen_random_str() {
  local length=${1:-40}
  local class=${2:-'A-Za-z0-9'}

  local str=$(head -c $(( $length * 30 )) /dev/urandom | tr -dc "$class")

  if [ ${#str} -lt $length ]; then
    return 1
  else
    echo "${str:0:$length}"
    return 0
  fi
}

gen_random_str_az_lower() {
  local length=${1:-6}
  local str

  wedp_gen_random_str $length a-z
}

is_valid_domain_string() {
  local input_str="$1"

  if [[ "$input_str" =~ ^[A-Za-z0-9.-]+$ ]]; then
    return 0
  else
    return 1
  fi
}

generate_username_string_from_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost" 1>&2
    return 1
  fi

  if ! is_valid_vhost_string "$vhost"; then
    echo "$FUNCNAME(): invalid format of vhost name" 1>&2
    return 1
  fi

  local username

  if [ ${#vhost} -le 6 ]; then
    username="w_$vhost"
  else # vhost length greater than 6
    local vhost_str vhost_str_1
    vhost_str="$vhost"
    vhost_str_1="${vhost_str:1}"

    # remove vogals after the 2nd position from $vhost string
    vhost_str="${vhost_str:0:1}${vhost_str_1//[aeiou-]/}"

    if [ -z "$vhost_str" ]; then
      # if it got empty from removing the vogals, then just return the first 6
      # positions of $vhost
      username="w_${vhost:0:6}"
    else
      username="w_${vhost_str:0:6}"
    fi
  fi

  echo "$username"
}

generate_linux_username_for_vhost() {
  local vhost="$1"

  unset _dp_value

  local user_str random_str

  user_str=$(generate_username_string_from_vhost "$vhost")
  if linuxuser_exists "$user_str"; then
    random_str=$(gen_random_str_az_lower 6) || return 1
    user_str="w_$random_str"
    if linuxuser_exists "$user_str"; then
      echo "$FUNCNAME(): unable to generate a unique name" 1>&2
      return 1
    fi
  fi

  _dp_value="$user_str"
  
  [ -n "$_dp_print" ] && printf '%s' "$_dp_value"

  return 0
}

get_linux_username_from_vhost() {
  local vhost="$1"

  local user

  get_key_value_from_vhost apache_vhost:_:linux_user "$vhost" && \
    user="$_dp_value"

  if [ $? -ne 0 ]; then
    user="w_$vhost"
    _dp_value="$user"
	fi
  
  [ -n "$_dp_print" ] && printf '%s' "$_dp_value"

  return 0
}

get_vhost_from_linuxuser() {
  local user="${1:-$USER}"
  local vhost

  if [ -z "$user" ]; then
    echo "$FUNCNAME(): unable to get username information" 1>&2
    return 1
  fi

  local map_dir map_link
  map_dir=$(get_linuxuser_vhost_dir)
  map_link="$map_dir/$user"
  if [ -L "$map_link" ]; then
    deref_contents "$map_link"
    return $?
  else
    # for servers installed before the $map_link was created
    if [ ${#user} -gt 2 -a "${user:0:2}" == w_ ]; then
      vhost=${user#w_}
      if vhost_exists "$vhost"; then
        echo "$vhost"
        return 0
      fi
    fi
  fi

  return 1
}

get_docroot_from_vhost() {
  local vhost="$1"

  local docroot_dir virtwww_homedir

  get_key_value_from_vhost apache_vhost:_:document_root "$vhost" && \
    docroot_dir="$_dp_value"

  if [ $? -ne 0 ]; then
    # backwards compatibility
    virtwww_homedir=$(deref_os_prop "$DEVPANEL_HOME" apache_virtwww_homedir) \
      || return 1

    docroot_dir="$virtwww_homedir/w_$vhost/public_html/$vhost"
	fi
  
  echo "$docroot_dir"

  return 0
}

get_docroot_from_user() {
  local user="${1:-$USER}"
  local vhost

  vhost=$(get_vhost_from_linuxuser "$user") || return 1

  get_docroot_from_vhost "$vhost"
}

get_linuxuser_vhost_dir() {
  echo "$DEVPANEL_HOME/config/key_value/linuxuser-vhost"
}

get_shell_from_user() {
  local user="${1:-$USER}"

  if [ -z "$user" ]; then
    echo "$FUNCNAME(): missing username" 1>&2
    return 1
  fi

  local passwd_line shell
  passwd_line=$(getent passwd "$user") || return $?

  shell=$(echo "$passwd_line" | cut -d: -f 7)
  if [ -n "$shell" ]; then
    echo "$shell"
    return 0
  else
    return 1
  fi
}

run_as_user() {
  local user="$1"
  shift
  local -a cmd_ar=( "$@" )

  if hash runuser &>/dev/null; then
    runuser -c "${cmd_ar[*]}" "$user"
  else
    su -c "${cmd_ar[*]}" "$user"
  fi
}

download_file() {
  local url="$1"
  local temp_file="$2"
  local retries=${3:-3}
  local wait_before_retry=${4:-20}

  if hash curl &>/dev/null; then
    curl -L -f --retry $retries --retry-delay $wait_before_retry -s -o "$temp_file" "$url"
    status=$?
  elif hash wget &>/dev/null; then
    wget -t $retries -w $wait_before_retry -nv -O "$temp_file" "$url"
    status=$?
  fi

  return $status
}

download_file_n_check_sha512() {
  download_file "$@" || return $?

  local file exp_sha sha512 

  file="$2"
  exp_sha="$5"


  sha512=$(calc_sha512_of_file "$file") || return $?

  if [ "$sha512" == "$exp_sha" ]; then
    return 0
  else
    echo "$FUNCNAME(): warning, sha512 '$sha512' doesn't match" \
         "the expected '$exp_sha'" 1>&2
    return 1
  fi
}

get_url_from_cache() {
  local url="$1"
  local retries=${3:-3}
  local wait_before_retry=${4:-5}

  local cache_dir=""
  if [ -n "$DEVPANEL_HOME" ]; then
    cache_dir="$DEVPANEL_HOME/var/seedapps_cache"
  else
    return 1
  fi

  local md5_txt=$(echo -n "$url" | md5sum | cut -d' ' -f 1)

  local cache_link="$cache_dir/$md5_txt:etag"
  if [ ! -L "$cache_link" ]; then
    return 1
  fi

  local tmp_headers_f=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  local resp_raw=""
  resp_raw=$(curl -w "%{http_code}"  -s -I \
    --retry $retries --retry-delay $wait_before_retry \
    -D "$tmp_headers_f" -o /dev/null "$url")
  local curl_st=$?

  code=${resp_raw%%*|}
  if [ $curl_st -ne 0 -o "$code" != "200"  ]; then
    rm -f -- "$tmp_headers_f"
    return 1
  fi

  local etag_raw=$(egrep -i ^ETAG: "$tmp_headers_f")
  if [ $? -ne 0 ]; then
    rm -f -- "$tmp_headers_f"
    return 1
  fi
  local etag_txt="${etag_raw#*: }"
  etag_txt=${etag_txt//[^a-f0-9-]/}

  rm -f -- "$tmp_headers_f"

  local etag_cached=$(readlink "$cache_link")
  if [ $? -ne 0 ]; then
    return 1
  fi

  if [ "$etag_txt" != "$etag_cached" ]; then
    return 1
  fi

  local cached_file="${cache_link%:etag}"
  if [ -s "$cached_file" ]; then
    echo -n "$cached_file"
    return 0
  else
    return 1
  fi
}

download_url_n_cache() {
  local url="$1"
  local temp_file="$2"
  local retries=${3:-3}
  local wait_before_retry=${4:-5}

  local tmp_headers_f=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temp file" 1>&2
    return 1
  fi

  local code="" error_msg="" resp_raw=""

  resp_raw=$(curl -w "%{http_code}"  -sL --retry $retries --retry-delay $wait_before_retry \
          -D "$tmp_headers_f" -o "$temp_file" "$url")
  local curl_st=$?

  code=${resp_raw%%*|}
  if [ $curl_st -ne 0 -o "$code" != "200"  ]; then
    rm -f -- "$tmp_headers_f"
    echo "$FUNCNAME(): failed to retrieve url $url" 1>&2
    return 1
  fi

  local etag_raw=$(egrep -i ^ETag: "$tmp_headers_f")
  if [ $? -ne 0 ]; then
    return 0 # won't cache, but it's fine, the file is downloaded
  fi

  local etag=${etag_raw#*: }
  if [ -z "$etag" ]; then
    return 0 # won't cache, but it's fine, the file is downloaded
  fi
  etag=${etag//[^a-f0-9-]/}

  local cache_dir="" mydir="" myfile=""
  if [ -n "$DEVPANEL_HOME" ]; then
    cache_dir="$DEVPANEL_HOME/var/seedapps_cache"
  else
    return 0
  fi 

  local md5_str=$(echo -n "$url" | md5sum | cut -d' ' -f 1)

  if [ -d "$cache_dir" ]; then
    local cache_file="$cache_dir/$md5_str:etag"
    ln -sf "$etag" "$cache_file"
    if [ $? -eq 0 ]; then
      local dest_file="${cache_file%:etag}"

      # the line below does the actual caching
      cp -f "$temp_file" "$dest_file"
    fi
  fi

  return 0
}

ini_section_get_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`

  sed -n -e "/^\[$section\]/,/^\[/ {
    /^\($key\)[[:space:]]*=.*$/ { s/^$key[[:space:]]*=[[:space:]]*//; p; q 0; }
  } ; $ q 1;" "$file"
}

ini_section_replace_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`
  local value=`escape_sed "$4"`

  local orig_md5 final_md5

  orig_md5=`md5sum "$file"`
  if [[ "$OSTYPE" =~ ^darwin ]]; then
    orig_md5=${orig_md5##* }
  else
    orig_md5=${orig_md5%% *}
  fi

  sed -i -e "/^\[$section\]/,/^\[/ {
    /^\($key\)[[:space:]]*=.*$/ {
      s/^\($key\)[[:space:]]*=.*$/\1 = $value/g;
    }
  }" "$file"

  local status=$?
  [ $status -ne 0 ] && return $status

  final_md5=`md5sum "$file"`
  if [[ "$OSTYPE" =~ ^darwin ]]; then
    final_md5=${final_md5##* }
  else
    final_md5=${final_md5%% *}
  fi

  if [ "$orig_md5" != "$final_md5" ]; then
    return 0 # file changed, success!
  else
    return 1 # file is the same, replace failed
  fi
}

ini_section_add_key_value() {
  local file="$1"
  local section=`escape_sed "$2"`
  local key=`escape_sed "$3"`
  local value=`escape_sed "$4"`

  local orig_md5=`md5sum "$file"`
  orig_md5=${orig_md5%% *}

  sed -i -e "/^\[$section\]/ {
    a \
$key = $value
}" "$file"

  local final_md5=`md5sum "$file"`
  final_md5=${final_md5%% *}

  if [ "$orig_md5" != "$final_md5" ]; then
    return 0 # file changed, success!
  else
    return 1 # file is the same, add failed
  fi
}

get_sshkey_fingerprint() {
  local key_text="$1"
  local tmp_file
  local key_line

  tmp_file=`mktemp`
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): could not create temporary file to store the key" 1>&2
    return 1
  fi

  echo "$key_text" >"$tmp_file"
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): could not store the key contents into tmpfile '$tmp_file'" 1>&2
    rm -f "$tmp_file"
    return 1
  fi

  key_line=`ssh-keygen -f "$tmp_file" -l`
  if [ $? -ne 0 ]; then
    echo "${FUNCNAME[0]}(): uname to calculate key fingerprint" 1>&2
    rm -f "$tmp_file"
    return 1
  fi

  rm -f "$tmp_file"

  local key_size key_fingerprint key_input_text
  IFS=" " read key_size fingerprint key_input_text <<< "$key_line"
  if [ -z "$fingerprint" ]; then
    echo "${FUNCNAME[0]}(): got an empty fingerprint" 1>&2
    return 1
  fi

  echo "$fingerprint"
  return 0
}

is_sshkey_in_keyfile() {
  local desired_fp="$1"
  local key_file="$2"
  local fp_list
  local key_line key_mod_size key_fp key_txt

  if ! fp_list=`ssh-keygen -f "$key_file" -l`; then
    echo "${FUNCNAME[0]}(): could not get the list of fingerprints" 1>&2
    return 1
  fi

  while read key_line; do
    IFS=" " read key_size key_fp key_txt <<< "$key_line"
    if [ "$key_fp" == "$desired_fp" ]; then
      return 0
    fi
  done <<< "$fp_list"

  return 1
}

devpanel_download_pkg() {
  local package="$1"
  local version="$2"
  local base_url="$3"
  local tmp_dir="${4:-/tmp}"

  local pkg_url="$base_url/$pkg_n_version.tar.gz"

  local tmp_pkg_dir="$tmp_dir/pkgs"
  if [ ! -d "$tmp_pkg_dir" ] && ! mkdir -m 700 "$tmp_pkg_dir"; then
    echo "$FUNCNAME(): unable to create temp dir '$tmp_pkg_dir'" 1>&2
    return 1
  fi

  if ! download_file "$pkg_url" "$tmp_file"; then
    echo "$FUNCNAME(): unable to download package '$package'" 1>&2
    return 1
  fi
}

devpanel_update_versioned_pkg_version() {
  local package="$1"
  local version="$2"
  local pkg_dir="$3"

  local target_dir="$pkg_dir/$package/$version"
  local target_link="$pkg_dir/$package/current"
  local status

  if [ ! -e "$target_dir" ]; then
    echo "$FUNCNAME(): dir '$target_dir' doesn't seem to exist" 1>&2
    return 1
  fi

  if [ ! -L "$target_link" -a -e "$target_link" ]; then
    echo "$FUNCNAME(): path '$target_link' exists but is not a symbolic link" 1>&2
    return 1
  elif [ -L "$target_link" ]; then
    rm -f "$target_link"
  fi

  ln -s "$version" "$target_link"
  status=$?
  if [ $status -ne 0 ]; then
    echo "$FUNCNAME(): unable to update target link '$target_link'" 1>&2
  fi

  return $status
}

devpanel_update_pkg_link_version() {
  local package="$1"
  local serial="$2"
  local version="$3"
  local system_dir="$4"

  local target_link="$system_dir/config/packages/$package/version"
  local serial_link="$system_dir/config/packages/$package/serial"
  local repo_link="$system_dir/config/packages/$package/repository"

  if [ ! -L "$target_link" -a -e "$target_link" ]; then
    echo "$FUNCNAME(): path '$target_link' exists but is not a symbolic link" 1>&2
    return 1
  elif [ -L "$target_link" ]; then
    rm -f "$target_link"
  fi

  ln -s "$version" "$target_link"
  local status=$?
  if [ $status -ne 0 ]; then
    echo "$FUNCNAME(): unable to update target link '$target_link'" 1>&2
  fi

  ln -sf "$serial" "$serial_link"
  ln -sf "devpanel" "$repo_link"

  return $status
}

calc_md5_str() {
  local str="$1"
  local md5_str=""

  if [[ "$OSTYPE" =~ ^darwin ]]; then
    md5_str=`echo -n "$str" | /sbin/md5`
  else
    md5_str=`echo -n "$str" | md5sum`
  fi

  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get md5sum of string" 1>&2
    return 1
  fi

  if [[ "$OSTYPE" =~ ^darwin ]]; then
    md5_str=${md5_str##* }
  else
    md5_str=${md5_str%% *}
  fi

  echo -n "$md5_str"

  return 0
}

calc_sha512_of_file() {
  local file="$1"

  if [ ! -e "$file" ]; then
    echo "$FUNCNAME(): non-existing path $file" 1>&2
    return 1
  elif [ ! -f "$file" ]; then
    echo "$FUNCNAME(): not a regular file $file" 1>&2
    return 1
  fi

  local line shastr
  line=$(sha512sum "$file")
  if [ $? -eq 0 ]; then
    shastr="${line%% *}"
    if [ -n "$shastr" ]; then
      echo "$shastr"
      return 0
    else
      echo "$FUNCNAME(): got unknown line from sha512sum '$line'" 1>&2
      return 1
    fi
  else
    echo "$FUNCNAME(): unable to calculate, sha512sum returned non-zero" 1>&2
    return 1
  fi
}

devpanel_get_os_version() {
  wedp_auto_detect_distro_version "$@"
}

devpanel_get_os_version_major() {
  local version="$1"
  local major=""

  if [ -z "$version" ]; then
    if ! hash lsb_release &>/dev/null; then
      echo "$FUNCNAME(): error - didn't find lsb_release in PATH" 1>&2
      return 1
    fi

    version=`lsb_release -sr 2>/dev/null`
    if [ -z "$version" ]; then
      echo "$FUNCNAME(): error, unable to get OS version" 1>&2
      return 1
    fi
  fi

  if [[ "$version" =~ ^[0-9]+\. ]]; then
    major=${version%%.*}
  else
    echo "$FUNCNAME(): got string '$version', don't know what to do" 1>&2
    return 1
  fi

  echo -n "$major"
}

devpanel_get_os_version_minor() {
  local version="$1"
  local minor=""

  if [ -z "$version" ]; then
    if ! hash lsb_release &>/dev/null; then
      echo "$FUNCNAME(): error - didn't find lsb_release in PATH" 1>&2
      return 1
    fi

    version=`lsb_release -sr 2>/dev/null`
    if [ -z "$version" ]; then
      echo "$FUNCNAME(): error, unable to get OS version" 1>&2
      return 1
    fi
  fi

  if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then # X.Y.Z
    minor=${version#*.}
    minor=${minor%.*}
  elif [[ "$version" =~ ^[0-9]+\.[0-9]+$ ]]; then # X.Y
    minor=${version#*.}
  else
    echo "$FUNCNAME(): got string '$version', don't know what to do" 1>&2
    return 1
  fi

  echo -n "$minor"
}

deref_contents() {
  local path="$1"

  local value=""

  if [ -L "$path" ]; then
    value=`readlink "$path"`
  elif [ -f "$path" ]; then
    value=`cat "$path"`
  elif [ ! -e "$path" ]; then
    echo "$FUNCNAME(): path doesn't exist $path" 1>&2
    return 1
  else
    echo "$FUNCNAME(): don't know how to de-reference path $path" 1>&2
    return 1
  fi

  echo -n "$value"
}

deref_contents_or_exit() {
  local path="$1"

  deref_contents "$path"
  if [ $? -eq 0 ]; then
    return 0
  else
    echo "Error: unable to de-reference path '$path'" 1>&2
    exit 1
  fi
}

assign_deref_contents_or_exit() {
  local var="$1"
  local path="$2"
  local value=""

  value=`deref_contents "$path"`
  if [ $? -ne 0 -o -z "$value" ]; then
    echo "Error: unable to de-reference path '$path'" 1>&2
    exit 1
  else
    eval $var="$value"
    return $?
  fi
}


deref_os_prop() {
  local base_dir="$1"
  local key_name="$2"

  local os_name="" os_version="" os_major=""
  local base_path="" key_path="" v="" resolved="" local_value=""
  local ver_specific="" ver_major="" os_specific="" devpanel_specific=""

  os_version=`devpanel_get_os_version`
  [ $? -ne 0 ] && return 1

  os_major=`devpanel_get_os_version_major "$os_version"`
  [ $? -ne 0 ] && return 1

  base_path="$base_dir/config/os"

  ver_specific="$base_path/$os_version/$key_name"
  ver_major="$base_path/$os_major/$key_name"
  os_specific="$base_path/$key_name"
  local_value="$base_dir/config/key_value/local/$key_name"
  devpanel_specific="$base_dir/config/key_value/$key_name"

  # check in this order:
  #   config/key_value/local/ -> local custom value
  #   os/<specific_version>   -> for the specific version
  #   os/<os_major>           -> for the specific major version
  #   os/                     -> for the specific distro
  #   config/key_value/       -> generic devPanel convention

  for v in "$local_value" "$ver_specific" "$ver_major" \
           "$os_specific" "$devpanel_specific"; do

    if [ -L "$v" -o -f "$v" ]; then
      key_path="$v"
      break
    fi
  done

  if [ -z "$key_path" ]; then
    echo "$FUNCNAME(): unable to find key $key_name in $base_dir" 1>&2
    return 1
  fi

  deref_contents "$key_path" || return 1
}

deref_os_prop_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_prop "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

assign_deref_os_prop_or_exit() {
  local var="$1"
  local base_dir="$2"
  local key_name="$3"

  local value=""

  value=`deref_os_prop "$base_dir" "$key_name"`
  if [ $? -ne 0 -o -z "$value" ]; then
    echo "Error: unable to de-reference key '$key_name'" 1>&2
    exit 1
  else
    eval $var="$value"
    return $?
  fi
}

get_system_key() {
  local key="$1"

  deref_os_prop "$DEVPANEL_HOME" "$key"
}

deref_os_fs_path() {
  local base_dir="$1"
  local key_name="$2"

  local orig_value="" value="" value_norm="" key_dir=""

  orig_value=`deref_os_prop "$base_dir" "$key_name"`
  [ $? -ne 0 -o -z "$orig_value" ] && return 1

  if [ "${orig_value:0:1}" != "/" ]; then
    key_dir=`dirname "$base_dir/config/os/$key_name"`
    value="$key_dir/$orig_value"
  else
    value="$orig_value"
  fi
  
  # existence of the target path not required
  value_norm=`readlink -m "$value"`

  echo -n "$value_norm"
}

deref_os_fs_path_ex() {
  # the different from deref_os_fs_path() is that this _ex() function
  # requires the file existence
  local base_dir="$1"
  local key_name="$2"

  local orig_value="" value="" value_norm="" key_dir=""

  orig_value=`deref_os_prop "$base_dir" "$key_name"`
  [ $? -ne 0 -o -z "$orig_value" ] && return 1

  if [ "${orig_value:0:1}" != "/" ]; then
    key_dir=`dirname "$base_dir/config/os/$key_name"`
    value="$key_dir/$orig_value"
  else
    value="$orig_value"
  fi

  # requires the existence of the target path
  value_norm=`readlink -e "$value"`
  [ $? -ne 0 ] && return 1

  echo -n "$value_norm"
}


deref_os_fs_path_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_fs_path "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

deref_os_fs_path_ex_or_exit() {
  local base_dir="$1"
  local key_name="$2"

  deref_os_fs_path_ex "$base_dir" "$key_name"
  [ $? -ne 0 ] && exit 1
}

assign_deref_os_fs_path_ex_or_exit() {
  local var="$1"
  local base_dir="$2"
  local key_name="$3"

  local value=""

  value=`deref_os_fs_path_ex "$base_dir" "$key_name"`
  if [ $? -eq 0 -a -n "$value" ]; then
    eval $var="$value"
    return $?
  else
    echo "Error: unable to dereference path: $key_name" 1>&2
    exit 1
  fi
}

get_lock_filename() {
  local orig_name="$1"

  if [ -z "$1" ]; then
    echo "$FUNCNAME(): error, missing file name" 1>&2
    return 1
  fi

  local real_path dir_name basename lock_file
  real_path=$(readlink -m "$orig_name")
  if [ $? -ne 0 -o -z "$real_path" ]; then
    return 1
  fi

  dir_name=${real_path%/*}
  basename=${real_path##*/}

  lock_file="$dir_name/.$basename.lock"

  echo "$lock_file"
}

lock_path() {
  local path="$1"
  local sleep_n="${2:-0.1}"
  local -i max_retries="${3:-100}"

  local lock_file=""

  lock_file=$(get_lock_filename "$path") || return 1

  local -i retries=1
  while [ $retries -le $max_retries ]; do
    ln -s "pid:$BASHPID" "$lock_file" 2>/dev/null
    if [ $? -eq 0 ]; then
      printf '%s' "$lock_file"
      return 0
    else
      sleep $sleep_n
    fi
    retries+=1
  done

  wedp_warn "unable to lock path '$path', timed out"
  return 1 # failed
}

unlock_path() {
  local path="$1"
  
  local lock_file=""

  lock_file=$(get_lock_filename "$path")

  if [ ! -L "$lock_file" -a ! -e "$lock_file" ]; then
    wedp_warn "didn't find lock file '$lock_file'"
    return 0
  elif [ ! -L "$lock_file" ]; then
    echo "$FUNCNAME(): path '$lock_file' is not a symlink" 1>&2
    return 1
  fi

  rm -f "$lock_file"
}

rm_rf_safer() {
  local dir="$1"

  if [ -z "$dir" -o ! -d "$dir" ]; then
    return 1
  fi

  local dir_full_path=`readlink -e "$dir"`
  if [ $? -ne 0 -o -z "$dir_full_path" ]; then
    echo "$FUNCNAME(): unable to determine full path of '$dir'" 1>&2
    return 1
  fi

  if [ "$dir_full_path" == "/" ]; then
    echo "$FUNCNAME(): can't use dir as /" 1>&2
    return 1
  fi

  rm -rf "$dir_full_path"
}

get_metadata_value() {
  local dir="$1"
  local key="`basename "$2"`"

  local user_def_path="$dir/local/$key"
  local usual_path="$dir/$key"
  local link_path="" link_value=""

  if [ -L "$user_def_path" ]; then
    link_path="$user_def_path"
  elif [ -L "$usual_path" ]; then
    link_path="$usual_path"
  else
    echo "$FUNCNAME(): didn't find key '$2'" 1>&2
    return 1
  fi

  link_value="`readlink "$link_path"`"
  if [ $? -eq 0 ]; then
    echo "$link_value"
    return 0
  else
    echo "$FUNCNAME(): found, but couldn't read link value on '$link_path'" 1>&2
    return 1
  fi
}

get_apache_metadata_value() {
  local system_dir="$1"
  local key="$2"

  local apache_config_dir="$system_dir/config/vhosts"
  local vhost
  vhost=$(get_vhost_from_linuxuser) || return $?

  local vhost_conf_dir="$apache_config_dir/$vhost"

  if [ ! -d "$vhost_conf_dir" ]; then
    echo "$FUNCNAME(): missing vhost conf dir $vhost_conf_dir" 1>&2
    return 1
  fi

  get_metadata_value "$vhost_conf_dir" "$key"
}

is_vhost_enabled() {
  local vhost="$1"

  is_vhost_locked "$vhost" >/dev/null 2>&1
}

is_vhost_locked() {
  local vhost="$1"

  local key="flag:locked"

  local value

  get_vhost_key_value "$key" "$vhost" >/dev/null
}

is_valid_port_number() {
  local port="$1"

  if [ -z "$port" ]; then
    echo "$FUNCNAME(): missing port" 1>&2
    return 1
  fi

  if [[ ! "$port" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME(): invalid port string" 1>&2
    return 1
  fi

  if [ $port -ge 0 -a $port -le 65535 ]; then
    return 0
  else
    echo "$FUNCNAME(): port out of range, must be within 0-65535" 1>&2
    return 1
  fi
}

is_valid_vhost_string() {
  local string="$1"

  if [ -z "$string" ]; then
    echo "$FUNCNAME(): received an empty vhost string" 1>&2
    return 1
  fi

  local vhost_regex='^[a-z0-9]+[a-z0-9-]+$'

  if [[ "$string" =~ $vhost_regex ]]; then
    return 0
  else
    return 1
  fi
}

vhost_exists() {
  local test_str="$1"

  if [ -z "$test_str" ]; then
    echo "$FUNCNAME(): received an empty vhost string" 1>&2
    return 1
  fi

  if ! is_valid_vhost_string "$test_str"; then
    echo "$FUNCNAME(): invalid format of vhost name" 1>&2
    return 1
  fi

  local config_dir="$DEVPANEL_HOME/config/vhosts/$test_str"
  if [ -d "$config_dir" ]; then
    return 0
  else
    return 1
  fi
}

linuxuser_exists() {
  local user="$1"

  if getent -- passwd "$user" &>/dev/null; then
    return 0
  else
    return 1
  fi
}

is_distro_updates_enabled() {
  deref_os_prop "$DEVPANEL_HOME" automatic_distro_updates &>/dev/null
}

are_snapshots_enabled_for_vhost() {
  local vhost="$1"
  local freq="$2"
  local _var

  for _var in vhost freq; do 
    if [ -z "${!_var}" ]; then
      echo "$FUNCNAME(): missing $_var" 1>&2
      return 1
    fi
  done

  local key="config:backup_snapshot:$freq:enabled"
  get_vhost_key_value "$key" "$vhost" &>/dev/null
}

get_snapshot_defs_for_vhost() {
  # returns the definitions of a vhost snapshot in a single line, with
  # elements separated by space. In the format: day hour retention_unit
  # note: daily backups don't have the 'day' field 

  local vhost="$1"
  local freq="$2"
  local _var

  for _var in vhost freq; do 
    if [ -z "${!_var}" ]; then
      echo "$FUNCNAME(): missing $_var" 1>&2
      return 1
    fi
  done

  if ! in_array "$freq" daily weekly monthly; then
    echo "$FUNCNAME(): invalid frequency received" 1>&2
    return 1
  fi

  if ! are_snapshots_enabled_for_vhost "$vhost" "$freq"; then
    echo "$FUNCNAME(): $freq snapshots disabled for vhost $vhost" 1>&2
    return 1
  fi

  local day day_name hour retention_unit
  local key_prefix="config:backup_snapshot:$freq"

  if [ "$freq" != daily ]; then
    day=$(get_vhost_key_value "$key_prefix:day" "$vhost") || return $?
    day_name=$(translate_daynumber_to_name "$day") || return $?
  fi

  hour=$(get_vhost_key_value "$key_prefix:hour" "$vhost") || return $?
  retention_unit=$(get_vhost_key_value "$key_prefix:retention_unit" \
                    "$vhost") || return $?

  local out_str
  if [ "$freq" != daily ]; then
    out_str+="$day_name "
  fi

  out_str+="$hour $retention_unit"

  echo "$out_str"
}

date_placeholders() {
  local template_str="$1"
  local ref_date="${2:-now}"

  if [ -n "$ref_date" ] && ! [[ "$ref_date" =~ ^[A-Za-z0-9\ -]+$ ]]; then
    echo "$FUNCNAME(): invalid ref_date" 1>&2
    return 1
  fi

  # local fmt_str='+%d %b %m %Y %H %M'
  local fmt_str='+%d %b %m %Y %H %M %W %w %s %j %a %x %X %Z %z'

  # local day month monthn year hour minute
  local day month_name month_number year hour minute \
        week_year day_week epoch day_year day_name   \
        locale_date locale_time timezone_abrev timezone_num

  IFS=" " read day month_name month_number year hour minute \
               week_year day_week epoch day_year day_name   \
               locale_date locale_time timezone_abrev timezone_num \
            <<< $(date -d "$ref_date" "$fmt_str")

  local date_str

  date_str="$template_str"
  date_str=${date_str//@day@/"$day"}
  date_str=${date_str//@month_name@/"$month_name"}
  date_str=${date_str//@month_number@/"$monthn"}
  date_str=${date_str//@year@/"$year"}
  date_str=${date_str//@hour@/"$hour"}
  date_str=${date_str//@minute@/"$minute"}
  date_str=${date_str//@week_year@/"$week_year"}
  date_str=${date_str//@day_week@/"$day_week"}
  date_str=${date_str//@epoch@/"$epoch"}
  date_str=${date_str//@day_year@/"$day_year"}
  date_str=${date_str//@day_name@/"$day_name"}
  date_str=${date_str//@locale_date@/"$locale_date"}
  date_str=${date_str//@locale_time@/"$locale_time"}
  date_str=${date_str//@timezone_abrev@/"$timezone_abrev"}
  date_str=${date_str//@timezone_num@/"$timezone_num"}

  # auxiliary formats for breviety
  date_str=${date_str//@aux_date_str@/$month_name-$day-$year}

  printf '%s' "$date_str"
}

get_mysql_version() {
  if ! hash mysql &>/dev/null; then
    echo "$FUNCNAME(): missing mysql command" 1>&2
    return 1
  fi

  local tmp_str
  tmp_str=$(mysql -V 2>/dev/null | egrep -o 'Distrib [0-9]\.[0-9]+(\.[0-9]+)?')
  if [ $? -ne 0 -o -z "$tmp_str" ]; then
    echo "$FUNCNAME(): unable to get mysql version from mysql command" 1>&2
    return 1
  fi

  local junk version_str
  IFS=" " read junk version_str <<< "$tmp_str"

  echo -n "$version_str"
}

get_php_version() {
  if hash php-config &>/dev/null; then
    php-config --version
    return $?
  elif hash php &>/dev/null; then
    local tmp_str=$(php -v | egrep -o 'PHP [0-9]\.[0-9]+\.[0-9]+')
    if [ $? -ne 0 -o -z "$tmp_str" ]; then
      echo "$FUNCNAME(): unable to get version string from php command" 1>&2
      return 1
    fi
    local junk ver_str 
    IFS=" " read junk ver_str <<< "$tmp_str"

    echo -n "$ver_str"
    return 0
  fi

  echo "$FUNCNAME(): php doesn't seem to be installed" 1>&2
  return 1
}

run_verbose() {
    echo "Running command: $@"
    "$@"
}

is_valid_mysql_db_or_table_name() {
  local str="$1"

  [ -z "$str" ] && return 1

  if [[ "$str" =~ ^[A-Za-z0-9_]+$ ]]; then
    return 0
  else
    return 1
  fi
}

is_mysql_engine_supported() {
  local engine="$1"

  local sql_tmpl='SELECT * FROM ENGINES WHERE ENGINE = "%s" 
                  AND SUPPORT IN("YES", "DEFAULT");'

  sql_line=$(printf "$sql_tmpl" "$engine")

  local output=""
  output=$(mysql -BN -D information_schema -e "$sql_line")
  if [ $? -ne 0 ]; then
    return 1
  fi

  if [ -n "$output" ]; then
    return 0
  else
    return 1
  fi
}

escape_quotes() {
  local orig="$1"
  local new="$orig"

  new=${new//\\/\\\\}
  new=${new//\'/\\\'}
  new=${new//\"/\\\"}

  printf '%s' "$new"
}

get_vhost_base_domain() {
  # returns the real base domain of a vhost
  local vhost="$1"

  local domain_int base_domain key

  key="apache_vhost:0:_:base_domain"

  if ! domain_int=$(get_vhost_key_value "$key" "$vhost" 2>/dev/null); then
    domain_int="$vhost"
  fi

  base_domain=$(get_real_hostname "$domain_int") || return $?

  echo "$base_domain"
}

get_vhost_default_hostname() {
  # returns the default hostname of the vhost
  # (i.e the one used on ServerName and in the app's config

  local vhost="$1"
  
  local key="apache_vhost:0:_:ServerName"
  local hostname

  hostname=$(get_vhost_key_value "$key" "$vhost") || return $?
  if [ $? -eq 0 ]; then
    echo "$hostname"
  else
    echo "$FUNCNAME(): unable to get default hostname from vhost $vhost" 1>&2
    return 1
  fi
}

is_ssl_enabled_on_vhost() {
  local vhost="$1"

  local conf_dir="$DEVPANEL_HOME/config/vhosts/$vhost"
  local ssl_link="$conf_dir/apache_vhost:_:name:default_ssl"

  if [ -L "$ssl_link" ]; then
    return 0
  else
    return 1
  fi
}

is_lets_encrypt_enabled_for_vhost() {
  local vhost="$1"

  local enabled

  enabled=$(get_vhost_key_value apache_vhost:_:config:lets_encrypt "$vhost" 2>/dev/null)
  if [ -n "$enabled" ]; then
    return 0
  else
    return 1
  fi
}

get_main_url_of_vhost() {
  local vhost="$1"
  local url domain

  if is_ssl_enabled_on_vhost "$vhost"; then
    url="https://"
  else
    url="http://"
  fi

  domain=$(get_vhost_default_hostname "$vhost") || return $?

  url+="$domain"
  url+="/"

  echo "$url"
}

set_vhost_default_hostname() {
  local vhost="$1"
  local hostname="$2"

  local metadata_str key
  key="apache_vhost:0:_:ServerName"
  metadata_str="set $key $hostname"

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
                           -q "$vhost"

  if [ $? -eq 0 ]; then
    return 0
  else
    echo "$FUNCNAME(): unable to set default domain for vhost $vhost" 1>&2
    return 1
  fi
}

set_vhost_base_domain() {
  local vhost="$1"
  local domain="$2"

  local int_name metadata_str

  if [ -z "$domain" ]; then
    int_name=$(format_hostname_internal "$vhost") || return $?
  else
    int_name=$(format_hostname_internal "$domain") || return $?
  fi

  metadata_str="set apache_vhost:0:_:base_domain $int_name"

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
                           -q "$vhost"

  if [ $? -eq 0 ]; then
    return 0
  else
    echo "$FUNCNAME(): unable to set base domain for vhost $vhost" 1>&2
    return 1
  fi
}

get_server_base_domain() {
  local system_dir="${1:-$DEVPANEL_HOME}"
  local domain

  domain=$(deref_os_prop "$system_dir" apache_virtwww_domain)
  if [ $? -eq 0 ]; then
    echo "$domain"
  else
    echo "$FUNCNAME(): unable to get virtwww base domain" 1>&2
    return 1
  fi
}

format_hostname_internal() {
  local test_hostname="$1"
  local force_subdomain="${2:-0}"
  local base_domain="$3"

  if [ -z "$base_domain" ]; then
    base_domain=$(get_server_base_domain) || return $?
  fi

  local test_host_stripped="" final_hostname="" has_dot=""

  if [[ "$test_hostname" =~ \. ]]; then
   has_dot=1
  fi

  # remove the server hostname from the end of name
  if [ "${test_hostname: -1}" == "." ]; then
    test_host_stripped=${test_hostname%.$base_domain.}
  else
    test_host_stripped=${test_hostname%.$base_domain}
  fi

  if [ "$force_subdomain" == "1" ]; then
    if [ "${test_hostname: -1}" == "." ]; then
      # $len_minus_one is a workaround for older bash versions that don't know
      # negative lengths (e.g. CentOS 6.5 and previous)
      local len_minus_one=$(( ${#test_hostname} - 1 ))
      final_hostname="${test_host_stripped:0:$len_minus_one}"
    else
      final_hostname="$test_host_stripped"
    fi
  else
    if [ "$test_host_stripped" != "$test_hostname" ]; then
      # had the server name successfully stripped, so it's a subdomain
      final_hostname="$test_host_stripped"
    elif [ "${test_hostname: -1}" == "." ]; then
      # if the hostname ends with a dot, then take it as fully defined
      final_hostname="$test_hostname"
    elif [ -n "$has_dot" ]; then
      # hostname doesn't end with a dot, but has a dot in the name
      # so let's guess it's a full domain
      final_hostname="$test_hostname."
    else
      # hostname doesn't end with a dot, doesn't have a dot
      # consider it a sub domain of the default server domain
      final_hostname="$test_hostname"
    fi
  fi

  echo -n "$final_hostname"
}

get_real_hostname() {
  local hostname="$1"

  local host_fmt="" server_base_domain=""

  if [ "${hostname: -1}" == "." ]; then
    # $len_minus_one is a workaround for older bash versions that don't know
    # negative lengths (e.g. CentOS 6.5 and previous)
    local len_minus_one=$(( ${#hostname} - 1 ))
    host_fmt="${hostname:0:$len_minus_one}" # remove the last dot
  else
    server_base_domain=$(get_server_base_domain) || return $?   
    host_fmt="$hostname.$server_base_domain"
  fi

  echo -n "$host_fmt"
}

get_list_of_vhosts() {
  local vhost_config_dir="$DEVPANEL_HOME/config/vhosts"
  local vhost vhost_dir
  local -a vhosts_ar=()

  if [ ! -d "$vhost_config_dir" ]; then
    echo "$FUNCNAME(): missing config dir $vhost_config_dir" 1>&2
    return 1
  fi

  for vhost_dir in "$vhost_config_dir/"*; do
    [ ! -d "$vhost_dir" ] && continue
    vhost=${vhost_dir##*/}
    vhosts_ar+=( "$vhost" )
  done

  if [ ${#vhosts_ar[*]} -le 0 ]; then
    return 0
  else
    echo "${vhosts_ar[@]}"
  fi
}

get_list_of_local_vhosts() {
  get_list_of_vhosts "$@"
}

get_vhost_with_hostname() {
  local hostname="$1"

  local tst_vhost tst_main tst_conf_dir 
  local tst_alias_link tst_value tst_base_link tst_link
  local hostname_fmt

  hostname_fmt=$(format_hostname_internal "$hostname")

  local base_addr="apache_vhost:0:_:base_domain"
  local default_base="apache_vhost:0:_:ServerName"
  local alias_base="apache_vhost:0:_:ServerAlias"

  for tst_vhost in $(get_list_of_vhosts); do
    tst_conf_dir="$DEVPANEL_HOME/config/vhosts/$tst_vhost"

    tst_link="$tst_conf_dir/$alias_base:$hostname_fmt"
    if [ -L "$tst_link" ]; then
      echo "$tst_vhost"
      return 0
    fi

    tst_base_link="$tst_conf_dir/$base_addr"
    tst_main_link="$tst_conf_dir/$default_base"

    for tst_link in "$tst_base_link" "$tst_main_link"; do
      if tst_value=$(deref_contents "$tst_link" 2>/dev/null); then
        if [ "$tst_value" == "$hostname" ]; then
          echo "$tst_vhost"
          return 0
        fi
      fi
    done
  done

  return 1 # not found in any vhost
}

get_hostnames_from_vhost() {
  local vhost="$1"

  local vhost_conf_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  local base_domain default_domain
  local tmp_link tmp_name tmp_fmt_name 
  local -a hosts_ar=()

  base_domain=$(get_vhost_base_domain "$vhost") || return $?

  default_domain=$(get_vhost_default_hostname "$vhost") || return $?

  hosts_ar+=( "$base_domain" )
  if [ "$base_domain" != "$default_domain" ]; then
    hosts_ar+=( "$default_domain" )
  fi

  for tmp_link in "$vhost_conf_dir/apache_vhost:0:_:ServerAlias:"*; do
    if [ ! -L "$tmp_link" ]; then
      continue
    fi

    # apache_vhost:0:_:ServerAlias:domain.com.
    tmp_name=${tmp_link##*:}
    tmp_fmt_name=$(get_real_hostname "$tmp_name") || return $?

    if [ "$tmp_fmt_name" == "$base_domain" ]; then
      continue
    fi

    hosts_ar+=( $tmp_fmt_name )
  done

  local IFS=$'\n'
  echo "${hosts_ar[*]}"
}

translate_archive_placeholders() {
  local orig="$1"
  local final

  # uses globals $sys_data_dir $vhost_data_dir $vhost $period
  #              $archive_template_str $removed_vhosts_dir

  final="$orig"

  [ -n "$archive_template_str" ] && \
    final=${final//@archive_template_str@/$archive_template_str}

  [ -n "$sys_data_dir" ]   && final=${final//@system_data_dir@/$sys_data_dir}

  [ -n "$vhost_archive_dir" ] && \
    final=${final//@vhost_archive_dir@/$vhost_archive_dir}

  [ -n "$removed_vhosts_dir" ] && \
    final=${final//@removed_vhosts_dir@/$removed_vhosts_dir}

  [ -n "$vhost" ]        && final=${final//@vhost@/$vhost}
  [ -n "$frequency" ]    && final=${final//@frequency@/$frequency}

  final=$(date_placeholders "$final") || return 1

  echo "$final"
}

get_recurring_backup_property() {
  local period="$1"
  local unit="$2"
  local vhost="$3"

  local vhost_config_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  local link="$vhost_config_dir/config:backup_snapshot:$period:$unit"

  deref_contents "$link"
}

get_vhost_key_value() {
  local key="$1"
  local vhost="$2"
  local value=""

  if [ -z "$vhost" ]; then
    if ! vhost=$(get_vhost_from_linuxuser); then
      echo "$FUNCNAME(): missing vhost, please specify it" 1>&2
      return 1
    fi
  fi

  is_valid_vhost_string "$vhost" || return $?

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local key_link="$DEVPANEL_HOME/config/vhosts/$vhost/$key"

  deref_contents "$key_link"
}

is_longer_vhost_names_enabled() {
  deref_os_prop "$DEVPANEL_HOME" enable_long_vhost_names &>/dev/null
}

is_valid_php_version_string() {
  local str="$1"

  if [ -z "$str" ]; then
    echo "$FUNCNAME(): missing version string argument" 1>&2
    return 1
  fi

  if [[ "$str" == [1-9].[0-9] ]]; then
    return 0
  else
    echo "$FUNCNAME(): invalid format specified for PHP version" 1>&2
    return 1
  fi
}

set_php_version_metadata_for_vhost() {
  local vhost="$1"
  local version="$2"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost argument" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  echo "rm app:0:_:php_version
set app:0:_:php_version $version" | \
    "$DEVPANEL_HOME/libexec/apache-metadata-handler" -q "$vhost"
}

rm_php_version_metadata_for_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost argument" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi
 
  echo "rm app:0:_:php_version" | \
    "$DEVPANEL_HOME/libexec/apache-metadata-handler" -q "$vhost"
}

is_known_seedapp_subsystem() {
  local name="${1##*/}"
  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing subsystem name" 1>&2
    return 1
  fi

  local app_dir="$DEVPANEL_HOME/bin/seeds/$name"

  if [ -d "$app_dir" ]; then
    return 0
  else
    return 1
  fi
}

has_min_path_matches() {
  local t_dir="$1"
  local -i n_min_matches=$2
  local -i n_matches=0

  if [ $# -lt 3 ]; then
    echo "$FUNCNAME(): error - missing arguments" 1>&2
    return 1
  fi

  shift 2

  local t_path

  while [ -n "$1" ]; do
    t_path="$t_dir/$1"
    if [ -e "$t_path" ]; then
      n_matches+=1
    fi
    shift

    if [ $n_matches -ge $n_min_matches ]; then
      return 0
    fi
  done

  return 1
}

detect_app_type_on_dir() {
  local t_dir="$1"
  local min_matches=3

  local app_type

  local -a d6_paths=( includes/bootstrap.inc modules index.php update.php )
  local -a d7_paths=( includes/bootstrap.inc modules index.php update.php )
  local -a d8_paths=( core/lib/Drupal autoload.php modules index.php update.php )
  local -a wordpress_v4_paths=( wp-config.php wp-content wp-includes \
                                      wp-login.php wp-admin )


  if has_min_path_matches "$t_dir" $min_matches "${d6_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${d7_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${d8_paths[@]}"; then
    app_type=drupal
  elif has_min_path_matches "$t_dir" $min_matches "${wordpress_v4_paths[@]}"; then
    app_type=wordpress
  else
    return 1
  fi

  if [ -n "$app_type" ]; then
    echo -n "$app_type"
    return 0
  else
    return 1
  fi
}

translate_dayname_to_number() {
  local name="${1,,}"
  local n

  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing name" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $name in
    sunday|sun)
      n=0
      ;;
    monday|mon)
      n=1
      ;;
    tuesday|tue)
      n=2
      ;;
    wednesday|wed)
      n=3
      ;;
    thursday|thu)
      n=4
      ;;
    friday|fri)
      n=5
      ;;
    saturday|sat)
      n=6
      ;;
    *)
      echo "$FUNCNAME(): unknown day" 1>&2
      return 1
      ;;
  esac

  echo "$n"
}

translate_daynumber_to_name() {
  local number="$1"
  local name

  if [ -z "$number" ]; then
    echo "$FUNCNAME(): missing parameter number" 1>&2
    return 1
  elif [[ "$number" == [0-6] ]]; then
    : # ok
  else
    echo "$FUNCNAME(): invalid number, needs to be between 0 and 6" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $number in
    0)
      name=sunday
      ;;
    1)
      name=monday
      ;;
    2)
      name=tuesday
      ;;
    3)
      name=wednesday
      ;;
    4)
      name=thursday
      ;;
    5)
      name=friday
      ;;
    6)
      name=saturday
      ;;
    *)
      echo "$FUNCNAME(): don't know how to translate '$number' to name" 1>&2
      return 1
      ;;
  esac

  echo "$name"
}

generate_vhost_ini_str() {
  local vhost="$1"

  local ini_str=""
  local db_name subsystem daily_snapshots_en weekly_snapshots_en monthly_snapshots_en
  local daily_hour daily_retention weekly_hour weekly_retention monthly_hour monthly_retention
  local weekly_day_raw weekly_day monthly_day_raw monthly_day
  local htpasswd_en php_version table_prefix

  local rec_snap_str="recurring_snapshots"

  db_name=$(get_vhost_key_value app:0:_:db_name "$vhost" 2>/dev/null)
  table_prefix=$(get_vhost_key_value app:0:_:table_prefix "$vhost" 2>/dev/null)
  subsystem=$(get_vhost_key_value app:0:_:seed_app "$vhost" 2>/dev/null)
  htpasswd_en=$(get_vhost_key_value flag:htpasswd_locked "$vhost" 2>/dev/null )
  php_version=$(get_vhost_key_value app:0:_:php_version "$vhost" 2>/dev/null )

  if [ -n "$db_name" ]; then
    ini_str+="app.database_name = $db_name"$'\n'
  fi

  if [ -n "$table_prefix" ]; then
    ini_str+="app.table_prefix = $table_prefix"$'\n'
  fi

  if [ -n "$subsystem" ]; then
    ini_str+="app.subsystem = $subsystem"$'\n'
  fi

  if [ -n "$htpasswd_en" ]; then
    ini_str+="vhost.htpasswd = yes"$'\n'
  fi

  if [ -n "$php_version" ]; then
    ini_str+="php.version = $php_version"$'\n'
  fi

  daily_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:daily:enabled "$vhost" \
                          2>/dev/null )
  weekly_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:weekly:enabled "$vhost" \
                          2>/dev/null )
  monthly_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:monthly:enabled "$vhost" \
                          2>/dev/null )

  if [ -n "$daily_snapshots_en" ]; then
    daily_hour=$(get_vhost_key_value config:backup_snapshot:daily:hour \
                  "$vhost" 2>/dev/null )
    daily_retention=$(get_vhost_key_value config:backup_snapshot:daily:retention_unit \
                      "$vhost" 2>/dev/null )

    if [ -n "$daily_hour" -a -n "$daily_retention" ]; then
      ini_str+="$rec_snap_str.daily_hour = $daily_hour"$'\n'
      ini_str+="$rec_snap_str.daily_retention = $daily_retention"$'\n'
    fi
  fi

  if [ -n "$weekly_snapshots_en" ]; then
    weekly_hour=$(get_vhost_key_value config:backup_snapshot:weekly:hour \
                  "$vhost" 2>/dev/null )
    weekly_day_raw=$(get_vhost_key_value config:backup_snapshot:weekly:day \
                  "$vhost" 2>/dev/null )
    weekly_day=$(translate_daynumber_to_name "$weekly_day_raw" 2>/dev/null)

    weekly_retention=$(get_vhost_key_value config:backup_snapshot:weekly:retention_unit \
                        "$vhost" 2>/dev/null )

    if [ -n "$weekly_day" -a -n "$weekly_hour" -a -n "$weekly_retention" ]; then
      ini_str+="$rec_snap_str.weekly_day = $weekly_day"$'\n'
      ini_str+="$rec_snap_str.weekly_hour = $weekly_hour"$'\n'
      ini_str+="$rec_snap_str.weekly_retention = $weekly_retention"$'\n'
    fi
  fi

  if [ -n "$monthly_snapshots_en" ]; then
    monthly_hour=$(get_vhost_key_value config:backup_snapshot:monthly:hour \
                    "$vhost" 2>/dev/null )
    monthly_day_raw=$(get_vhost_key_value config:backup_snapshot:monthly:retention_unit \
                    "$vhost" 2>/dev/null )
    monthly_day=$(translate_daynumber_to_name "$monthly_day_raw" 2>/dev/null)
    monthly_retention=$(get_vhost_key_value config:backup_snapshot:monthly:retention_unit \
                         "$vhost" 2>/dev/null )

    if [ -n "$monthly_day" -a -n "$monthly_hour" -a -n "$monthly_retention" ]; then
      ini_str+="$rec_snap_str.monthly_day = $monthly_day"$'\n'
      ini_str+="$rec_snap_str.monthly_hour = $monthly_hour"$'\n'
      ini_str+="$rec_snap_str.monthly_retention = $monthly_retention"$'\n'
    fi
  fi

  echo -n "$ini_str"
}

dump_vhost_mysql_db() {
  local vhost="$1"
  local database="$2"

  if ! "$DEVPANEL_HOME/libexec/check-vhost-name" archive "$vhost"; then
    return 1
  fi

  local temp_my_cnf
  local mysql_host mysql_port mysql_user mysql_pass
  mysql_host=$(get_vhost_key_value app:0:_:db_host "$vhost" 2>/dev/null)
  mysql_port=$(get_vhost_key_value app:0:_:db_port "$vhost" 2>/dev/null)
  mysql_user=$(get_vhost_key_value app:0:_:db_user "$vhost" 2>/dev/null)
  mysql_pass=$(get_vhost_key_value app:0:_:db_password "$vhost" 2>/dev/null)
  
  if [ -z "$database" ]; then
    database=$(get_vhost_key_value app:0:_:db_name "$vhost" 2>/dev/null)
    if [ $? -ne 0 ]; then
      echo "$FUNCNAME(): unable to get database name for vhost $vhost" 1>&2
      return 1
    fi
  fi

  if ! temp_my_cnf=$(mktemp); then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  echo "
client.host = $mysql_host
client.port = $mysql_port
client.user = $mysql_user
client.password = $mysql_pass
" | "$DEVPANEL_HOME/bin/update-ini-file" -q -c "$temp_my_cnf"
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to write ini file '$temp_my_cnf'" 1>&2
    rm -f "$temp_my_cnf"
    return 1
  fi

  local st

  mysqldump --defaults-extra-file="$temp_my_cnf" "$database"
  st=$?

  rm -f "$temp_my_cnf"

  return $st
}

translate_dayname_to_number() {
  local name="${1,,}"
  local n

  if [ -z "$name" ]; then
    echo "$FUNCNAME(): missing name" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $name in
    sunday|sun)
      n=0
      ;;
    monday|mon)
      n=1
      ;;
    tuesday|tue)
      n=2
      ;;
    wednesday|wed)
      n=3
      ;;
    thursday|thu)
      n=4
      ;;
    friday|fri)
      n=5
      ;;
    saturday|sat)
      n=6
      ;;
    *)
      echo "$FUNCNAME(): unknown day" 1>&2
      return 1
      ;;
  esac

  echo "$n"
}

translate_daynumber_to_name() {
  local number="$1"
  local name

  if [ -z "$number" ]; then
    echo "$FUNCNAME(): missing parameter number" 1>&2
    return 1
  elif [[ "$number" == [0-6] ]]; then
    : # ok
  else
    echo "$FUNCNAME(): invalid number, needs to be between 0 and 6" 1>&2
    return 1
  fi

  # could use a global associative array, not using for backwards
  # compatibility with older bash versions

  case $number in
    0)
      name=sunday
      ;;
    1)
      name=monday
      ;;
    2)
      name=tuesday
      ;;
    3)
      name=wednesday
      ;;
    4)
      name=thursday
      ;;
    5)
      name=friday
      ;;
    6)
      name=saturday
      ;;
    *)
      echo "$FUNCNAME(): don't know how to translate '$number' to name" 1>&2
      return 1
      ;;
  esac

  echo "$name"
}

bytes_to_human() {
  local -i n_bytes="$1"
  local n_bytes_human unit

  local -i kb=1024 mb=$(( 1024 * 1024 )) gb=$(( 1024 * 1024 * 1024 ))

  if [ -z "$n_bytes" ] || ! [[ "$n_bytes" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  if [ $n_bytes -gt $gb ]; then
    unit='gb'
  elif [ $n_bytes -gt $mb ]; then
    unit='mb'
  elif [ $n_bytes -gt $kb ]; then
    unit='kb'
  fi

  n_bytes_human=$(echo "scale = 2; $n_bytes / ${!unit}" | bc -l)

  echo -n "$n_bytes_human ${unit^^}"
}


get_ssl_cert_path_from_vhost() {
  local vhost="$1"

  if [ -z "$vhost" ]; then
    echo "$FUNCNAME(): missing vhost" 1>&2
    return 1
  fi

  if ! vhost_exists "$vhost"; then
    return 1
  fi

  if ! is_ssl_enabled_on_vhost "$vhost"; then
    echo "$FUNCNAME(): SSL not enable for vhost $vhost" 1>&2
    return 1
  fi

  local cert_dir cert_file

  cert_dir="$DEVPANEL_HOME/config/os/pathnames/etc/ssl/certs"
  cert_file="$cert_dir/$vhost.default_ssl.crt"

  echo "$cert_file"
  return 0
}

get_field_from_ssl_cert_file() {
  local field="$1"
  local file="$2"

  if [ -z "$field" ]; then
    echo "$FUNCNAME(): missing field argument" 1>&2
    return 1
  elif [ -z "$file" ]; then
    echo "$FUNCNAME(): missing file argument" 1>&2
    return 1
  elif [[ ! "$field" =~ ^[A-Za-z0-9]+$ ]]; then
    echo "$FUNCNAME(): received field in an invalid format" 1>&2
    return 1
  fi

  if [ ! -f "$file" ]; then
    echo "$FUNCNAME(): missing file '$file'" 1>&2
    return 1
  fi

  local field_txt

  field_txt=$(openssl x509 -noout -"$field" -in "$file" 2>/dev/null)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get field from cert" 1>&2
    return 1
  fi

  echo "$field_txt"
  return 0
}

get_subject_from_ssl_cert_file() {
  local file="$1"

  get_field_from_ssl_cert_file subject "$file"
}

get_cn_from_ssl_cert_file() {
  local file="$1"

  local tmp_subj cn

  tmp_subj=$(get_subject_from_ssl_cert_file "$file") || return $?

  if cn=$(get_cn_from_asn_string "$tmp_subj"); then
    echo "$cn"
    return 0
  else
    return 1
  fi
}

get_cn_from_asn_string() {
  local asn="$1"
  
  if [ -z "$asn" ]; then
    echo "$FUNCNAME(): missing ASN string" 1>&2
    return 1
  fi

  local cn

  if [[ "$asn" == *CN=* ]]; then
    cn="${asn##*CN=}"
    cn="${cn#CN=}"
    cn="${cn%/*}"
    echo "$cn"
    return 0
  else
    echo "$FUNCNAME(): unable to parse CN information" 1>&2
    return 1
  fi
}

get_start_date_from_ssl_cert() {
  # echoes the start date of a SSL cert
  local file="$1"

  local tmp_start_str start_date

  tmp_start_str=$(get_field_from_ssl_cert_file startdate "$file") || \
    return $?

  start_date=${tmp_start_str#notBefore=}
  echo "$start_date"
  return 0
}

get_exp_date_from_ssl_cert() {
  # echoes the expiration date of a SSL cert
  local file="$1"

  local tmp_exp_str exp_date

  tmp_exp_str=$(get_field_from_ssl_cert_file enddate "$file") || return $?

  exp_date=${tmp_exp_str#notAfter=}
  echo "$exp_date"
  return 0
}

get_issuer_from_ssl_cert() {
  local file="$1"

  get_field_from_ssl_cert_file issuer "$file"
}

get_issuer_cn_from_ssl_cert() {
  local file="$1"

  local tmp_issuer_str issuer_cn

  tmp_issuer_str=$(get_issuer_from_ssl_cert "$file") || return $?

  issuer_cn=$(get_cn_from_asn_string "$tmp_issuer_str") || return $?

  echo "$issuer_cn"
}

generate_vhost_ini_str() {
  local vhost="$1"

  local ini_str=""
  local db_name subsystem daily_snapshots_en weekly_snapshots_en monthly_snapshots_en
  local daily_hour daily_retention weekly_hour weekly_retention monthly_hour monthly_retention
  local weekly_day_raw weekly_day monthly_day_raw monthly_day
  local htpasswd_en php_version table_prefix

  local rec_snap_str="recurring_snapshots"

  db_name=$(get_vhost_key_value app:0:_:db_name "$vhost" 2>/dev/null)
  table_prefix=$(get_vhost_key_value app:0:_:table_prefix "$vhost" 2>/dev/null)
  subsystem=$(get_vhost_key_value app:0:_:seed_app "$vhost" 2>/dev/null)
  htpasswd_en=$(get_vhost_key_value flag:htpasswd_locked "$vhost" 2>/dev/null )
  php_version=$(get_vhost_key_value app:0:_:php_version "$vhost" 2>/dev/null )

  if [ -n "$db_name" ]; then
    ini_str+="app.database_name = $db_name"$'\n'
  fi

  if [ -n "$table_prefix" ]; then
    ini_str+="app.table_prefix = $table_prefix"$'\n'
  fi

  if [ -n "$subsystem" ]; then
    ini_str+="app.subsystem = $subsystem"$'\n'
  fi

  if [ -n "$htpasswd_en" ]; then
    ini_str+="vhost.htpasswd = yes"$'\n'
  fi

  if [ -n "$php_version" ]; then
    ini_str+="php.version = $php_version"$'\n'
  fi

  daily_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:daily:enabled "$vhost" \
                          2>/dev/null )
  weekly_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:weekly:enabled "$vhost" \
                          2>/dev/null )
  monthly_snapshots_en=$(get_vhost_key_value \
                          config:backup_snapshot:monthly:enabled "$vhost" \
                          2>/dev/null )

  if [ -n "$daily_snapshots_en" ]; then
    daily_hour=$(get_vhost_key_value config:backup_snapshot:daily:hour \
                  "$vhost" 2>/dev/null )
    daily_retention=$(get_vhost_key_value config:backup_snapshot:daily:retention_unit \
                      "$vhost" 2>/dev/null )

    if [ -n "$daily_hour" -a -n "$daily_retention" ]; then
      ini_str+="$rec_snap_str.daily_hour = $daily_hour"$'\n'
      ini_str+="$rec_snap_str.daily_retention = $daily_retention"$'\n'
    fi
  fi

  if [ -n "$weekly_snapshots_en" ]; then
    weekly_hour=$(get_vhost_key_value config:backup_snapshot:weekly:hour \
                  "$vhost" 2>/dev/null )
    weekly_day_raw=$(get_vhost_key_value config:backup_snapshot:weekly:day \
                  "$vhost" 2>/dev/null )
    weekly_day=$(translate_daynumber_to_name "$weekly_day_raw" 2>/dev/null)

    weekly_retention=$(get_vhost_key_value config:backup_snapshot:weekly:retention_unit \
                        "$vhost" 2>/dev/null )

    if [ -n "$weekly_day" -a -n "$weekly_hour" -a -n "$weekly_retention" ]; then
      ini_str+="$rec_snap_str.weekly_day = $weekly_day"$'\n'
      ini_str+="$rec_snap_str.weekly_hour = $weekly_hour"$'\n'
      ini_str+="$rec_snap_str.weekly_retention = $weekly_retention"$'\n'
    fi
  fi

  if [ -n "$monthly_snapshots_en" ]; then
    monthly_hour=$(get_vhost_key_value config:backup_snapshot:monthly:hour \
                    "$vhost" 2>/dev/null )
    monthly_day_raw=$(get_vhost_key_value config:backup_snapshot:monthly:retention_unit \
                    "$vhost" 2>/dev/null )
    monthly_day=$(translate_daynumber_to_name "$monthly_day_raw" 2>/dev/null)
    monthly_retention=$(get_vhost_key_value config:backup_snapshot:monthly:retention_unit \
                         "$vhost" 2>/dev/null )

    if [ -n "$monthly_day" -a -n "$monthly_hour" -a -n "$monthly_retention" ]; then
      ini_str+="$rec_snap_str.monthly_day = $monthly_day"$'\n'
      ini_str+="$rec_snap_str.monthly_hour = $monthly_hour"$'\n'
      ini_str+="$rec_snap_str.monthly_retention = $monthly_retention"$'\n'
    fi
  fi

  echo -n "$ini_str"
}

get_key_value_from_vhost() {
  local key="$1"
  local vhost="${2:-$_dp_vhost}"

  local value
  unset _dp_value

  value=$(deref_contents \
            "$DEVPANEL_HOME/config/vhosts/$vhost/$key" 2>/dev/null) || return $?

	_dp_value="$value"

  [ -n "$_dp_print" ] && printf '%s' "$value"

  return 0
}

get_1st_level_field_value_from_app() {
  local vhost="$1"
  local field="$2"
  local prefix="app:0:_"
  local value

  value=$(get_vhost_key_value "$prefix:$field" "$vhost" 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo -n "$value"
    return 0
  else
    return 1
  fi
}

get_app_type_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" seed_app
}

is_htpasswd_enabled_on_vhost() {
  local vhost="$1"
  local en

  en=$(get_vhost_key_value flag:htpasswd_locked "$vhost" 2>/dev/null )
  if [ $? -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

is_fastcgi_enabled_on_vhost() {
  local vhost="$1"
  local key="apache_vhost:0:include:fastcgi"
  local en

  en=$(get_vhost_key_value "$key" "$vhost" 2>/dev/null )
  if [ $? -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

get_mysql_db_name_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_name
}

get_mysql_db_host_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_host
}

get_mysql_db_port_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" db_port
}

get_mysql_db_host_port_from_vhost() {
  local vhost="$1"
  local db_host db_port

  db_host=$(get_mysql_db_host_from_vhost "$vhost" 2>/dev/null)
  db_port=$(get_mysql_db_port_from_vhost "$vhost" 2>/dev/null)

  if [ -n "$db_host" -a -n "$db_port" ]; then
    echo "$db_host:$db_port"
    return 0
  else
    return 1
  fi
}

print_vhost_summary() {
  local vhost="$1"

  local summ_txt="
Information about vhost @vhost@

Main URL: @main_url@

Domains: @domains@
SSL: @ssl_txt@
App: @app_type@
PHP Version: @php_version@
SFTP User: @ssh_user@
SFTP Host: @ssh_host@
MySQL Host/Port: @db_host_port@
MySQL Database:  @db_name@
FastCGI: @fastcgi_status@
Htpasswd: @htpasswd_status@
Snapshots: @snapshots_txt@
"

  if should_skip_nginx_vhost "$vhost"; then
    summ_txt+="Skipping nginx vhost: Yes"$'\n'
  fi

  local -a domains_ar=( $(get_hostnames_from_vhost "$vhost") )
  local domains_txt="" out_txt=""
  local main_url ssh_host ssh_user db_name db_host_port db_name app_type
  local fastcgi_status htpasswd_status
  local snapshots_txt snap_daily_txt snap_weekly_txt snap_monthly_txt
  local ssl_txt php_ver

  main_url=$(get_main_url_of_vhost "$vhost")
  app_type=$(get_app_type_from_vhost "$vhost")
  db_host_port=$(get_mysql_db_host_port_from_vhost "$vhost")
  db_name=$(get_mysql_db_name_from_vhost "$vhost")

  if is_fastcgi_enabled_on_vhost "$vhost"; then
    fastcgi_status=enabled
  else
    fastcgi_status=disabled
  fi
  
  if is_htpasswd_enabled_on_vhost "$vhost"; then
    htpasswd_status=enabled
  else
    htpasswd_status=disabled
  fi

  domains_txt+=$'\n'
  for domain in "${domains_ar[@]}"; do
    domains_txt+="    $domain"$'\n'
  done

  get_linux_username_from_vhost "$vhost" && \
    ssh_user="$_dp_value"

  snap_daily_txt=$(get_snapshot_defs_for_vhost   "$vhost" daily   2>/dev/null)
  snap_weekly_txt=$(get_snapshot_defs_for_vhost  "$vhost" weekly  2>/dev/null)
  snap_monthly_txt=$(get_snapshot_defs_for_vhost "$vhost" monthly 2>/dev/null)

  if [ -n "$snap_daily_txt" -o -n "$snap_weekly_txt" -o \
       -n "$snap_monthly_txt" ]; then

    snapshots_txt="enabled"

    local _var _tst_freq _freq_txt
    local s_freq s_day s_hour s_ret_unit
    for _tst_freq in daily weekly monthly; do
      _var="snap_${_tst_freq}_txt"
      if [ -n "${!_var}" ]; then
        if [ "$_tst_freq" == daily ]; then
          read s_hour s_ret_unit <<< "${!_var}"
          freq_txt="  $_tst_freq at hour $s_hour"
        else
          read s_day s_hour s_ret_unit <<< "${!_var}"
          freq_txt="  $_tst_freq on $s_day, at hour $s_hour"
        fi
        freq_txt+=", retain $s_ret_unit files"
        snapshots_txt+=$'\n'
        snapshots_txt+="$freq_txt"
      fi
    done
  else
    snapshots_txt="disabled"
  fi

  if is_ssl_enabled_on_vhost "$vhost"; then
    ssl_txt+="enabled"

    local ssl_cert_file ssl_cert_start_date ssl_cert_exp_date ssl_cert_cn
    local ssl_issuer_cn
    
    ssl_cert_file=$(get_ssl_cert_path_from_vhost "$vhost" 2>/dev/null)
    if [ $? -eq 0 ]; then
      ssl_txt+=$'\n'
      ssl_issuer_cn=$(get_issuer_cn_from_ssl_cert "$ssl_cert_file" \
                        2>/dev/null )
      [ $? -eq 0 ] && ssl_txt+="  Issuer: $ssl_issuer_cn"$'\n'

      ssl_cert_cn=$(get_cn_from_ssl_cert_file "$ssl_cert_file" 2>/dev/null )
      [ $? -eq 0 ] && ssl_txt+="  CN: $ssl_cert_cn"$'\n'

      ssl_cert_start_date=$(get_start_date_from_ssl_cert "$ssl_cert_file" \
                              2>/dev/null )
      [ $? -eq 0 ] && ssl_txt+="  Valid after: $ssl_cert_start_date"$'\n'

      ssl_cert_exp_date=$(get_exp_date_from_ssl_cert "$ssl_cert_file" \
                              2>/dev/null )
      [ $? -eq 0 ] && ssl_txt+="  Expires On:  $ssl_cert_exp_date"$'\n'

      ssl_txt+="  HTTP to HTTPS redirect: "
      if is_https_redirect_enabled_for_vhost "$vhost"; then
        local https_redirect_domain
        ssl_txt+="yes"
        if https_redirect_domain=$(get_https_redirect_target_domain "$vhost"); then
          ssl_txt+=", targeted redirect to https://$https_redirect_domain"
        fi
        ssl_txt+=$'\n'
      else
        ssl_txt+="no"$'\n'
      fi
    fi
  else
    ssl_txt="disabled"
  fi

  php_ver=$(get_php_version_from_vhost "$vhost" 2>/dev/null )
  if [ $? -ne 0 ]; then
    local sys_php_ver
    sys_php_ver=$(get_default_php_version 2>/dev/null )
    if [ $? -eq 0 ]; then
      php_ver="$sys_php_ver (system default)"
    fi
  fi

  if has_user_includes "$vhost"; then
    summ_txt+="Custom Includes: yes"$'\n'
  fi
 
  ssh_host=$(get_server_base_domain)

  out_txt="$summ_txt"
  out_txt=${out_txt//@main_url@/$main_url}
  out_txt=${out_txt//@vhost@/$vhost}
  out_txt=${out_txt//@domains@/$domains_txt}
  out_txt=${out_txt//@ssl_txt@/$ssl_txt}
  out_txt=${out_txt//@app_type@/$app_type}
  out_txt=${out_txt//@php_version@/$php_ver}
  out_txt=${out_txt//@db_host_port@/$db_host_port}
  out_txt=${out_txt//@db_name@/$db_name}
  out_txt=${out_txt//@ssh_user@/$ssh_user}
  out_txt=${out_txt//@ssh_host@/$ssh_host}
  out_txt=${out_txt//@fastcgi_status@/$fastcgi_status}
  out_txt=${out_txt//@htpasswd_status@/$htpasswd_status}
  out_txt=${out_txt//@snapshots_txt@/$snapshots_txt}

  echo "$out_txt"
}

is_https_redirect_enabled_by_default() {
  local https_redirect

  https_redir=$(get_system_key https_redirect_enabled 2>/dev/null)
  if [ $? -eq 0 -a "$https_redir" == yes ]; then
    return 0
  else
    return 1
  fi
}

is_https_redirect_enabled_for_vhost() {
  local vhost="$1"
  local key value

  key="apache_vhost:0:_:https_redirect"

  value=$(get_vhost_key_value "$key" "$vhost" 2>/dev/null)
  if [ $? -eq 0 -a "$value" == yes ]; then
    return 0
  else
    return 1
  fi
}

set_https_redirect_metadata() {
  local vhost="$1"
  local domain="$2"

  local metadata_str tmpl tmpl_key
  local tmpl_key_all="names/https_redirect_template"
  local tmpl_key_domain="names/https_redirect_targeted_template"

  if [ -n "$domain" ]; then
    tmpl_key="$tmpl_key_domain"
  else
    tmpl_key="$tmpl_key_all"
  fi

  if tmpl=$(get_system_key "$tmpl_key"); then
    metadata_str+="set apache_vhost:0:_:https_redirect yes"$'\n'
    metadata_str+="set apache_vhost:0:_:template_ref $tmpl_key"$'\n'

    if [ -n "$domain" ]; then
      metadata_str+="set apache_vhost:0:var:https_redirect_target_domain $domain"$'\n'
    fi

    echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
      -q "$vhost"
  else
    echo "$FUNCNAME(): unable to get template name for https_redirect" 1>&2
    return 1
  fi
}

unset_https_redirect_metadata() {
  local vhost="$1"

  local metadata_str tmpl
  local tmpl_key="names/apache_vhost_template"

  if tmpl=$(get_system_key "$tmpl_key"); then
    metadata_str+="rm  apache_vhost:0:_:https_redirect"$'\n'
    metadata_str+="rm  apache_vhost:0:var:https_redirect_target_domain"$'\n'
    metadata_str+="set apache_vhost:0:_:template_ref $tmpl_key"$'\n'

    echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
      -q "$vhost"
  else
    echo "$FUNCNAME(): unable to get template name for apache_vhost_template" 1>&2
    return 1
  fi
}

get_https_redirect_target_domain() {
  local vhost="$1"

  local key value
  key="apache_vhost:0:var:https_redirect_target_domain"

  value=$(get_vhost_key_value "$key" "$vhost" 2>/dev/null)
  if [ $? -eq 0 -a -n "$value" ]; then
    echo "$value"
    return 0
  else
    return 1
  fi

}

set_user_include_metadata() {
  local vhost="$1"
  local tmpl_name="$2"

  local metadata_str

  metadata_str="set apache_vhost:0:user_include:$tmpl_name $tmpl_name"$'\n'

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
    -q "$vhost"

}

unset_user_include_metadata() {
  local vhost="$1"
  local tmpl_name="$2"

  local metadata_str

  metadata_str="rm apache_vhost:0:user_include:$tmpl_name"$'\n'

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
    -q "$vhost"
}

get_user_include_metadata() {
  local vhost="$1"
  local tmpl_name="$2"

  local key="apache_vhost:0:user_include:$tmpl_name"

  get_vhost_key_value "$key" "$vhost" 
}

get_vhost_include_filename() {
  local vhost="$1"

  local file_base
  local config_dir="$DEVPANEL_HOME/config/vhosts/$vhost"

  file_base=$(get_user_include_metadata "$vhost" user_includes)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to get user include base name" 1>&2
    return 1
  fi

  local config_file="$config_dir/$file_base.inc"

  echo "$config_file"
}

has_user_includes() {
  local vhost="$1"

  get_user_include_metadata "$vhost" user_includes &>/dev/null
}

ltsv_get_value() {
  local key="$1"
  local line="${2:-$_ltsv_line}"

  unset _ltsv_value

  local value tmp_ext_1 tmp_ext_2

  if ! [[ "$line" == *$key:* ]]; then
    return 1
  fi

  tmp_ext_1=${line#$key:}
  if [ "$tmp_ext_1" != "$line" ]; then
    # parameter is the first one on the line
    # remove any remaining text
    value=${tmp_ext_1%%$'\t'*}
  else
    # check beyond the first position
    tmp_ext_2=${line##*$'\t'$key:}
    if [ "$tmp_ext_2" == "$line" ]; then
      return 1 # parameter not found
    else
      # remove any remaining text
      value=${tmp_ext_2%%$'\t'*}
    fi
  fi

  _ltsv_value="$value"

  [ -n "$_ltsv_print" ] && printf '%s' "$value"

  return 0
}

ltsv_has_key_with_value() {
  local key="$1"
  local wanted_value="$2"
  local line="${3:-$_ltsv_line}"
  local found_value=""

  ltsv_get_value "$key" "$line" || return 1

  found_value="$_ltsv_value"
  if [ "$found_value" == "$wanted_value" ]; then
    return 0
  else
    return 1
  fi
}

ltsv_find_line_with_keys_n_values() {
	local file="$1"
  shift

  local -a keys_ar values_ar
  local key value line
  while [ -n "$1" ]; do
    key=${1%%=*}
    value=${1#*=}

    keys_ar+=( "$key" )
    values_ar+=( "$value" )
    shift
  done

  local -i n_keys=${#keys_ar[@]}
  while read line; do
    [ -z "$line"           ] && continue
    [ "${line:0:1}" == "#" ] && continue

    _ltsv_line="$line"

    local -i max_n=$(( $n_keys - 1 ))
    for((i=0; i <= $max_n; i++)); do
      key=${keys_ar[$i]}
      value=${values_ar[$i]}

      if ltsv_has_key_with_value "$key" "$value"; then
        if [ $i == $max_n ]; then
          # test all key-values, and all matched
          echo "$line"
          return 0
        fi
      else
        break
      fi
    done
  done < "$file"

  unset _ltsv_line
  return 1
}

get_default_app_publisher() {
  deref_os_prop "$DEVPANEL_HOME" default_app_publisher
}

get_base_url_for_publisher() {
  local publisher="$1"
  local key="${publisher}_seedapps_base_url"

  deref_os_prop "$DEVPANEL_HOME" "$key"
}

get_app_metadata_from_publisher() {
  local publisher="$1"
  local tmp_file="$2"

  local base_url metadata_url
  local created_tmp

  base_url=$(get_base_url_for_publisher "$publisher") || return $?
  metadata_url="${base_url%/}/metadata.ltsv"

  if [ -z "$tmp_file" ]; then
    tmp_file=$(mktemp)
    if [ $? -eq 0 ]; then
      created_tmp=1
    else
      echo "$FUNCNAME(): unable to create temporary file" 1>&2
      return 1
    fi
  fi

  download_file "$metadata_url" "$tmp_file"
  local st=$?
  if [ $st -eq 0 ]; then
    if [ -n "$created_tmp" ]; then
      cat "$tmp_file"
      rm -f "$tmp_file"
    fi
  else
    echo "$FUNCNAME(): unable to get app metadata from $publisher" 1>&2
  fi

  return $st
}

get_app_info_from_publisher() {
  local app="$1"
  local publisher="$2"
  local tmp_file

  tmp_file=$(mktemp)
  if [ $? -ne 0 ]; then
    echo "$FUNCNAME(): unable to create temporary file" 1>&2
    return 1
  fi

  if ! get_app_metadata_from_publisher "$publisher" "$tmp_file"; then
    rm -f "$tmp_file"
    return 1
  fi

  local info_txt
  info_txt=$(ltsv_find_line_with_keys_n_values "$tmp_file" name="$app")
  local st=$?

  if [ $st -eq 0 ]; then
    echo "$info_txt"
  fi

  rm -f "$tmp_file"

  return $st
}

get_tarball_url_for_app() {
  local app="$1"
  local publisher="$2"

  local -a info_ar=()
  local old_IFS="$IFS"
  IFS=$'\n' info_ar=( $( get_app_info_from_publisher "$app" "$publisher") )
  local st=$?
  IFS="$old_IFS"

  if [ $st -ne 0 ]; then
    echo "$FUNCNAME(): no such app '$app' on $publisher" 1>&2
    return $st
  elif [ -z "${info_ar[*]}" ]; then
    echo "$FUNCNAME(): no such app '$app' on $publisher" 1>&2
    return 1
  elif [ ${#info_ar[@]} -gt 1 ]; then
    echo "$FUNCNAME(): got more than one record for app '$app' on '$publisher'" 1>&2
    return 1
  fi
  
  local file_uri base_url real_url
  if ltsv_get_value file_uri "${info_ar[0]}"; then
    file_uri="$_ltsv_value"
  else
    echo "$FUNCNAME(): missing file_uri field for app $app" 1>&2
    return 1
  fi

  if ! ltsv_get_value enabled "${info_ar[0]}" ||
       [ "$_ltsv_value" != "true" ]; then

    echo "$FUNCNAME(): app '$app' is not enabled for installs" 1>&2
    return 1
  fi

  base_url=$(get_base_url_for_publisher "$publisher") || return $?
  real_url="${base_url%/}/${file_uri#/}"

  echo "$real_url"

  return 0
}

set_vhost_description() {
  local desc="$1"
  local vhost="$2"
  local metadata_str="set apache_vhost:_:opt:description $desc"

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
                          -q "$vhost"
}

get_vhost_description() {
  local vhost="$1"
  local key="apache_vhost:_:opt:description"

	get_vhost_key_value "$key" "$vhost" 2>/dev/null
}

remove_vhost_description() {
  local vhost="$1"

  local key="apache_vhost:_:opt:description"
  local metadata_str="rm $key"

  echo "$metadata_str" | "$DEVPANEL_HOME/libexec/apache-metadata-handler" \
                          -q "$vhost"
}

apache_ctl(){
  local action="$1"
  distro=$(devpanel_auto_detect_distro)

  case $distro in
    ubuntu|debian)
      service_name="apache2"
    ;;
    centos|redhat)
      service_name="httpd"
    ;;
  esac

  case $action in
    start)
      service ${service_name} start
    ;;
    stop)
      service ${service_name} stop
    ;;
    restart)
      service ${service_name} restart
    ;;
    reload)
      service ${service_name} reload
    ;;
    status)
      service ${service_name} status
    ;;
  esac
}

get_apache_ports_file() {
  deref_os_prop "$DEVPANEL_HOME" names/apache_ports_file
}

install_distro_pkgs() {
  local distro="$1"
  local distro_major_ver="$2"
  local pkg_list_file="$3"

  if [ $# -ne 3 -o -z "$1" -o -z "$2" -o -z "$3" ]; then
    echo "$FUNCNAME(): required args -" \
           "distro, distro_major_version, pkg_list_file" 1>&2
    return 1
  fi

  if [ ! -f "$pkg_list_file" ]; then
    echo "$FUNCNAME(): missing file '$pkg_list_file'" 1>&2
    return 1
  elif [ ! -s "$pkg_list_file" ]; then
    echo "$FUNCNAME(): list file '$pkg_list_file' is empty" 1>&2
    return 1
  fi

  local -a cmd_ar=()
  case "$distro" in
    centos|redhat)
      cmd_ar=( yum -y install )
      ;;
    debian|ubuntu)
      cmd_ar=( apt-get -y install )
      ;;
    *)
      echo "$FUNCNAME(): don't know how to install packages for distro" \
        "$distro" 1>&2
      return 1
      ;;
  esac

  local pkg_regex='^[[:space:]]*[^[:space:]#]+'

  if egrep -q "$pkg_regex" "$pkg_list_file"; then
    egrep "$pkg_regex" "$pkg_list_file" | xargs -n 100 "${cmd_ar[@]}"
  else
    echo "$FUNCNAME(): didn't find any package in the list" 1>&2
    return 1
  fi
}

get_php_version_from_vhost() {
  local vhost="$1"

  get_1st_level_field_value_from_app "$vhost" php_version
}

get_default_php_version() {
  deref_os_prop "$DEVPANEL_HOME" php_default_version
}

get_platform_version() {
  deref_os_prop "$DEVPANEL_HOME" platform_version
}

set_platform_version() {
  local version="$1"

  if [[ ! "$version" =~ ^[1-9]$ ]]; then
    echo "$FUNCNAME(): invalid version string specified (must be [1-9])" 1>&2
    return 1
  fi

  echo "set-local platform_version $version" | \
    "$DEVPANEL_HOME/libexec/system-metadata-handler" -q
}

is_nginx_on_port80() {
  local apache_port pids_on_port80 tst_pid pid_exe

  apache_port=$(get_apache_http_port ) || return $?

  if [ "$apache_port" != 80 ]; then
    if pids_on_port80=$(fuser 80/tcp 2>/dev/null ); then
      while [ -n "$pids_on_port80" -a "${pids_on_port80:0:1}" == " " ]; do
        # remove the leading space from the output
        pids_on_port80="${pids_on_port80# }"
      done

      # test the first pid to see if it's nginx
      tst_pid=${pids_on_port80%% *}

      pid_exe=$(readlink -e /proc/$tst_pid/exe ) || return $?
      if [[ "$pid_exe" == *nginx ]]; then
        return 0
      fi
    fi
  fi

  return 1
}

write_nginx_local_vhost() {
  local vhost="$1"

  if ! vhost_exists "$vhost"; then
    echo "$FUNCNAME(): vhost doesn't exist" 1>&2
    return 1
  fi

  local nginx_vhost_dir nginx_vhost_lnk_dir
  local vhost_base_domain vhost_file vhost_lnk vhost_hostnames vhost_txt
  local apache_http_port server_base_domain

  server_base_domain=$(get_server_base_domain )       || return $?
  vhost_base_domain=$(get_vhost_base_domain "$vhost") || return $?
  apache_http_port=$(get_apache_http_port )           || return $?

  nginx_vhost_dir="/etc/nginx/sites-available"
  if [ ! -d "$nginx_vhost_dir" ]
  then
      mkdir -p $nginx_vhost_dir
  fi
  nginx_vhost_lnk_dir="/etc/nginx/sites-enabled"

  vhost_file="$nginx_vhost_dir/$vhost_base_domain.conf"
  vhost_lnk="$nginx_vhost_lnk_dir/$vhost_base_domain.conf"

  local vhost_tmpl_txt='
server {
  listen       80;
  server_name  @vhost_hostnames@ @vhost@-gen.@server_base_domain@;
  location / {
    proxy_set_header Host $host;
    proxy_pass http://127.0.0.1:@apache_http_port@;
  }
}
'

  vhost_hostnames=$(get_hostnames_from_vhost "$vhost") || return $?
  vhost_hostnames=${vhost_hostnames//$'\n'/ }
  vhost_txt="$vhost_tmpl_txt"
  vhost_txt="${vhost_txt//@vhost@/$vhost}"
  vhost_txt="${vhost_txt//@server_base_domain@/$server_base_domain}"
  vhost_txt="${vhost_txt//@vhost_hostnames@/$vhost_hostnames}"
  vhost_txt="${vhost_txt//@apache_http_port@/$apache_http_port}"

  if echo "$vhost_txt" >"$vhost_file"; then
    rm -f "$vhost_lnk"
    ln -s "$vhost_file" "$vhost_lnk"
  else
    echo "$FUNCNAME(): unable to write vhost file '$vhost_file'" 1>&2
    return 1
  fi
}

should_skip_nginx_vhost() {
  local vhost="$1"

  if get_vhost_key_value skip_nginx_vhost "$vhost" &>/dev/null; then
    # key present, skip it
    return 0
  else
    # key not present, don't skip it (write it)
    return 1
  fi
}
